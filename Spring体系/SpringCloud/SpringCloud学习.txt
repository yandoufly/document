什么是微服务？
	微服务架构是一种架构模式，它将单体应用程序按业务拆分为一个个小的服务，每个服务运行在其独立的进程中，服务之间相互调用，最终为用户提供汇总服务。
	服务之间相互通信，在SpringCloud可以用RestTemplate+Ribbon和Feign来调用。
	客户端的请求首先通过负载均衡（zuul、nginx），再到达服务网关（zuul集群、SpringCloudGateway），然后再到具体的服务。
	服务统一注册到高可用的服务注册中心集群，服务的所有配置文件由配置服务管理，配置服务的配置文件放在git仓库。	
	
微服务优缺点？
	--优点：
	每个服务高内聚，代码容易理解；
	开发效率高，一个服务只做一件事；
	微服务松耦合，是仅具备某个功能的服务；
	可以用不同的开发语言，面向接口编程；
	可以灵活搭配,连接公共库/连接独立库
	--缺点：
	分布式系统的负责性
	多服务运维难度，随着服务的增加，运维的压力也在增大
	系统部署依赖
	服务间通信成本
	数据一致性

集中式系统和分布式系统区别？
	-1）集中式系统：一个主机带多个终端（如浏览器），终端没有数据处理能力，仅负责数据的录入和输出，而运算、存储等全部在主机上运行。
	-2）分布式系统：把一个计算任务分解为若干个计算单元，并分派到若干个不同的计算机中去执行，然后再汇总计算结果。
	附：终端（terminal），也称终端设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入及处理结果的输出等。

分布式和集群的区别？
	-1）分布式（distributed）：指多台不同的服务器中部署不同的服务模块，通过远程调用协同工作，对外提供服务
	-2）集群（cluster）：指在多台不同的服务器中部署相同的应用或服务模块，构成一个集群，通过负载均衡设备对外提供服务。

spring、springboot、SpringCloud关系？
	1、Spring两大核心功能IOC和AOP。
	2、springboot在spring生态基础上发展而来，它的出现是为了更容易的使用Spring，旨在快速搭建单体应用。它解决了传统框架配置文件复杂、装配组件繁杂等问题。
	3、springCloud。它利用Springboot的开发便利性，巧妙地简化了分布式系统基础设施的开发，如服务注册与发现、负载均衡、熔断器、配置管理、消息总线、路由网关、服务追踪等。
	总结：SpringBoot专注于快速方便地开发单体应用；SpringCloud基于SpringBoot开发，因此继承了SpringBoot的特性，其更专注于服务治理。

SpringCloud和dubbo区别？
	dubbo专注于RPC框架，其它的分布式技术需要依赖第三方技术来组装出一个分布式架构。现已弃用。
	SpringCloud是一系列框架的集合，提供了所有分布式架构需要的技术，不用依赖其它第三方技术，所以各组件间的兼容性很好。各服务之间通信使用http协议。
	Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。
	Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。

	1、SpringCloud和Dubbo都是现在主流的微服务架构。
	2、SpringCloud是Apache旗下的Spring体系下的微服务解决方案；Dubbo是阿里系的分布式服务治理框架从技术维度上，其实SpringCloud远远的超过Dubbo，Dubbo本身只是实现了服务治理，而SpringCloud现在以及有21个子项目以后还会更多。
	3、服务的调用方式Dubbo使用的是RPC远程调用，SpringCloud使用的是 Rest API,其实更符合微服务官方的定义。
	4、服务的注册中心来看，Dubbo使用了第三方的ZooKeeper作为其底层的注册中心，实现服务的注册和发现，SpringCloud使用Spring Cloud Netflix Eureka实现注册中心，当然SpringCloud也可以使用ZooKeeper实现，但一般我们不会这样做。
	5、服务网关，Dubbo并没有本身的实现，只能通过其他第三方技术的整合，SpringCloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发，SpringCloud还支持断路器，与git完美集成分布式配置文件支持版本控制，事务总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。

rest和rpc的区别？
	rest风格的系统交互更方便，rpc调用服务提供方和调用方式之间依赖太强。
	rest调用系统性能较低，rpc调用效率比rest高。
	rest的灵活性可以跨系统跨语言调用，rpc只能在同语言内调用。
	rest可以和swagger等工具整合，自动输出接口api文档。

	1、如果仔细阅读过微服务提出者马丁福勒的论文的话可以发现其定义的服务间通信机制就是http rest。
	2、rpc最主要的缺陷就是服务提供方和调用方式之间依赖太强，我们需要为每一个微服务进行接口的定义，并通过持续继承发布。需要严格的版本控制才不会出现服务提供和调用之间因为版本不同而产生的冲突。
	3、rest是轻量级的接口，服务的提供和调用不存在代码之间的耦合，只是通过一个约定进行规范，但也有可能出现文档和接口不一致而导致的服务集成问题，但可以通过swagger工具整合，是代码和文档一体化解决，所以rest在分布式环境下比rpc更加灵活。这也是为什么当当网的dubbox在对dubbo的增强中增加了对rest的支持的原因。



分布式配置方案：
	1、将整个系统按业务拆分成若干子系统或微服务，且每个子系统可部署多个应用，多个应用间使用负载均衡。
	2、需要一个注册中心EurekaServer，所有服务都将注册到注册中心。注册中心可部署多个，以保证高可用。
	3、所有服务EurekaClient都统一注册到注册中心，服务之间采用feign进行调用。每个服务可配置多个，调用同一服务可按照一定策略来实现负载均衡。
	4、所有客户端都通过统一网地址访问后台的服务，通过路由配置zuul或gwteway网关来判断一个url请求由哪个服务处理。请求转发到服务上的时候使用负载均衡Ribbon/feign。
	5、使用断路器 hystrix，及时处理服务调用时的超时和错误，防止由于其中一个服务的问题而导致整体系统的瘫痪。
	6、使用 SpringCloud Config 进行统一的配置管理，对所有服务的配置资源统一管理。
	7、Hystrix，监控和断路器。我们只需要在服务接口上添加 Hystrix 标签，就可以实现对这个接口的监控和断路器功能。
	8、还需要一个监控功能，监控每个服务调用花费的时间等。
	9、Hystrix Dashboard，监控面板，他提供了一个界面，可以监控各个服务上的服务调用所消耗的时间等。
	10、Turbine，监控聚合，使用 Hystrix 监控，我们需要打开每一个服务实例的监控信息来查看。而Turbine可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。这样就不需要挨个打开一个个的页面一个个查看。


SpringCloud常用组件：
	分布式微服务--SpringCLoud、Dubbo
	服务注册发现--Eureka、consul、zk、nacos
	客户端负载均衡--ribbon
	服务调用--feign
	断路器--Hystrix
	服务网关--Zuul
	分布式配置中心--SpringCloudConfig
	事件消息总线--Spring Cloud Bus

	服务的配置与管理 ： netfix 公司 archaius 阿里的diamond等
	服务的注册于发现 ：spriing cloud 所采用的 eureka ，consul,zookeeper 等
	服务的调用:rest GRPC RPC 
	服务的熔断器 ：hystrix envoy等
	负载均衡 ：ribbon .nginx
	服务接口调用(客户端调用服务的简化工具) Feign等消息队列Kafka、 Rabbitmq、 Activemq等
	服务配置中心管理Spring Cloud Config、Chef等服务路由(API网关)Zuu等
	服务监控Zabbix、 Nagios、 Metrics、 Spectator等
	全链路追踪Zipkin, Brave、 Dapper等
	服务部罟Docker、 Open Stack、 Kubernetes等
	数据流操作开发包--Spring Cloud Stream(封装redis,rabbit,kafka等发送接收消息)
说明：
	1）eureka
		包括注册中心(eureka server)和服务提供者(eureka client)
		各服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
	2）ribbon+restTemplate 2、feign --服务消费者、服务与服务之间负载均衡	
	3）Hystrix：熔断器
		测试：1、ribbon使用断路器hystrix 2、feign自带断路器 3、监控工具Hystrix-Dashboard
	4）Config：配置中心。配置文件统一管理。
	5）Zuul/gateway：路由转发和过滤器、网关。
		若前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务
		zuul默认和Ribbon结合实现了负载均衡的功能。比如／api/user转发到到user服务，/api/shop转发到到shop服务。

各组件总结：
	Eureka：各个服务启动时，EurekaClient都会将服务注册到EurekaServer，并且EurekaClient还可以反过来从EurekaServer拉取注册表，从而知道其他服务在哪里。
	Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台
	Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
	Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
	Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务

技术选型：
	开发语言：java + groovy，groovy的好处是网关服务不需要重启就可以动态的添加filter来实现一些功能；
	微服务基础框架：springboot；
	网关基础组件：netflix zuul；
	服务注册中心：consul；
	权限校验：jwt；
	API监控：prometheus + grafana；
	API统一日志收集：logback + ELK；
	压力测试：Jmeter；

*************************RPC理论*************************
分布式-CAP理论：
	CAP理论是由下面三个概念组成的，且在分布式系统中三者不可兼得，只能同时满足两种条件。
三个概念：
1.一致性(Consistency):
	all nodes see the same data at the same time.
	所有数据库集群节点的同一时间点看到的数据完全一致，即所有节点能实时保持数据同步。
	所有节点在同一时间具有相同的数据.
2.可用性(Availability):
	reads and writes always succeed.
	读写操作永远是成功的。即服务一直是可用的，即使集群一部分节点故障，集群整体还能正常响应客户端的读写请求。
	保证每个请求不管成功或者失败都有响应.
3.分区容错性(P):
	the system continues to operate despite arbitrary message loss or failure of part of the system.
	尽管系统中有任意的信息丢失或故障，都不会影响系统的继续运作。
	以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

CAP权衡使用：
	--1、保留CA，放弃P
	如果想避免分区容错性的发生，一种做法是将所有数据都放在一台机器上。缺点是影响系统的扩展性。
	作为一个分布式系统，放弃P，即相当于放弃了分布式，一旦并发性很高，单机服务根本不能承受压力。像很多银行服务，确确实实就是舍弃了P，只用单台小型机+ORACLE保证服务可用性。
	--2、保留CP，放弃A
	相对于放弃“分区容错性“来说，其反面就是放弃可用性。一旦遇到分区容错故障，那么受到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供服务。
	作为分布式系统，有分区服务发生问题很有可能，如果因为某些服务不能用，导致整个服务都不能用，这个根本不是好的分布式系统。
	--3、保留AP，舍弃C
	这里所说的放弃一致性，并不是完全放弃数据一致性，而是放弃数据的强一致性。即放弃了同一时刻的数据一致性，而保留数据的最终一致性。
	以网络购物为例，对只剩下一件库存的商品，如果同时接受到了两份订单，那么较晚的订单将被告知商品告罄。
	通常情况下，很多分布式服务系统都是采用该方案，保证可用性性，分布式服务，因为某些分区服务发生问题，先容忍，最终通过一些折中的方法达到最终数据一致性。

Zookeeper保证CP，Eureka保证AP：
	1、Zookeeper有主从概念，当master节点因为网络故障和其它节点失去联系，剩余节点会进行master选举。选举期间整个zk集群不可用（不能保证A），因而选举期间的注册服务瘫痪。
	2、Eureka没有主从概念，各节点平等。某节点挂掉不影响其它节点功能，其它节点照样提供查询和注册功能。Eureka客户端发现Eureka节点挂掉直接切换到其他正常的节点上去。只不过可能查到的数据不是最新的，也就是Eureka不保证数据的强一致性。
	总结：作为注册中心推荐Eureka，因为注册服务更重要的是可用性。




*************************服务注册与发现(Eureka)*************************
服务注册和发现是什么？SpringCloud如何实现？
	详情：https://www.iteye.com/blog/yangyangmyself-2334788 ！！
	详情：http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/
	答案：https://zhuanlan.zhihu.com/p/99164801?utm_source=qq&utm_medium=social&utm_oi=965555060286144512

概念：
	Eureka由两个组件组成：Eureka服务端(Eureka Server)和Eureka客户端(Eureka Client)。
	Eureka服务端是注册中心，提供服务注册服务，支持集群部署。
	Eureka客户端是系统中其它服务，需注册到Eureka服务端并维持心跳连接。在Eureka服务端的服务注册表中存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。
	Eureka客户端同时也具备了一个内置的、使用轮询(round-robin)负载均衡器。在应用启动后，将会向EurekaServer发送心跳（默认周期为30秒）。若EurekaServer在多个心跳周期内没有接收到某个节点的心跳，eurekaServer将会从服务注册表中把这个服务节点移除(默认90秒)。


服务注册中心(eureka服务端)：
	所有微服务集群都可以是它的客户端，来注册和订阅。
	启动：需要依赖spring-cloud-starter-eureka-server，并将主启动类标识@EnableEurekaServer。在yml配置文件中配置自己的访问地址等信息。默认情况下eureka server也是一个eureka client，必须要指定一个server。
	自我保护策略：在短时间内大量微服务没有心跳服务，会开启保护模式，不会立即删除注册表中没有心跳的微服务。当心跳回到阈值时会自动关闭保护模式。
	为什么需要自我保护策略？答：短时间内大量微服务没有心跳可能原因是注册中心网络中断了，无法与大部分服务连接。

	注册中心集群：
		#设置与eureka Server交互的地址查询服务和注册都需要依赖这个地址
		#defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #单机
		defaultZone: http://eureka1001:1001/eureka/,http://eureka1002:1002/eureka/ #集群

服务注册(eureka客户端)
	当eureka客户端向eurekaServer注册时，它提供自身的元数据，如ip地址、端口、运行状况指示符url、主页等。
	启动：需要依赖spring-cloud-starter-netflix-eureka-client，并将主启动类标识@EnableEurekaClient，在yml配置文件中指定注册中心的访问地址等信息，这样本服务启动后会自动注册进eureka服务注册中心中。
	每个服务单元向注册中心登记自己提供的服务，将主机、端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。

服务发现(服务消费者)：
	@EnableDiscoveryClient 本应用的主启动类上添加此注解表示：服务发现。进而可以在所有bean中使用DiscoveryClient接口来访问Eureka.或结合RestTemplate来访问Restful风格的http服务。


获取注册表信息(Fetch Register):
	eureka客户端从服务器获取注册信息并将其缓存在本地。客户端会使用该信息查询对应服务，从而进行远程调用。该注册列表信息定期（每隔30s）更新一次。每次返回注册列表信息可能与eureka客户端的缓存信息不同，eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，eureka客户端则会重新获取整个注册表信息。eureka服务器缓存注册列表信息，整个注册表及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。

服务续约(Renew)与服务剔除(Eviction)：
	--服务续约：
	Eureka客户端启动后，会周期性地向Eureka服务端发送心跳以续约自己的信息，避免自己的注册信息被剔除。续约的方式与服务注册基本一致：首先更新自身状态，再同步到其它Peer。
	eureka客户端默认会每隔30s发送一次心跳来续约。通过续约l来告知eurekaServer该eureka客户端仍然存在，没有问题。正常情况下，如果eurekaServer在90s没有收到eureka客户的续约，它会将该实例从其注册表中删除。
	--服务剔除：
	若Eureka服务端在一段时间内没有收到某微服务实例的心跳，Eureka服务端会将该微服务节点注销（自我保护模式除外）
	在默认的情况下，当eureka客户端连续90s（3个续约周期）没有向eureka服务器发送服务续约，即心跳，eureka服务器会将该服务实例从服务注册表删除。


服务下线(Cancel):
	eureka客户端在程序关闭时向eureka服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。
	该下线请求不会自动完成，它需要调用：DiscoveryManager.getInstance().shutdownComponent();


4.自我保护模式：
	描述：默认情况下，若Eureka服务端在一定时间内没有收到某服务实例的心跳，Eureka服务端会将该微服务节点注销（默认90秒）。但当网络分区故障发生时，Eureka客户端与Eureka服务端之间无法正常通信（即Eureka服务端的网络有问题），以上行为可能变得非常危险了，因为微服务本身其实健康的，此时本不应该注销该服务实例。

	当Eureka Server检测到大规模服务异常时，会自动进入自我保护机制：
		Eureka服务端不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。
		Eureka服务端仍然能够接收新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）。
		当网络稳定时，当前实例新的注册信息会被同步到其他节点中。
	
	解决：eureka通过“自我保护模式”来解决这个问题--当eurekaServer节点在短时间内丢失过多客户端时（可能发生网络分区故障），那么该节点就会进入自我保护模式。一旦进入该模式，eurekaServer就会保护服务注册表的信息，不在删除服务注册表中的数据（也就是不会注销任何微服务）。但网路故障恢复后，该eurekaServer节点会自动退出自我保护模式。

	在自我保护模式中，eurekaServer会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳重新恢复到阈值以上时，该eurekaServer节点就会自动退出自我保护模式。这样设计是为了宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。

5.Eureka三大角色(注册中心、服务提供者、服务消费者)：
	1、注册中心(eureka server)：
		提供服务注册与发现；
		在启动类上添加@EnableEurekaServer注解，表明自己是一个eurekaServer。
	2、服务提供者(eureka client)：
		即service，将自身服务注册到eureka，从而使服务消费方能够找到；
		当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。服务注册中心从每个client实例接收心跳消息。如果心跳超时，则通常将该实例从注册server中删除。
	3、服务消费者(eureka client + ribbon/feign)：
		即open-service，从eureka获取注册服务列表，从而能够消费服务。
		在微服务架构中，业务都会拆分成一个独立的服务，服务与服务的通讯是基于http restful的。
		Spring Cloud有两种服务调用方式：1）ribbon+restTemplate，2）feign。
		ribbon是一个负载均衡客户端，可以很好的控制http和tcp的一些行为。Feign默认集成了ribbon。


Eureka与zookeeper对比？
	--概括：
	Eureka有自我保护机制。没有主从概念。
	Zookeeper出现网络故障时会花30-120s来选举新master，而导致注册中心不可用，可用性不好。
	ZooKeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间不可用的。
	Eureka各个节点是平等关系，只要有一台Eureka就可以保证服务可用，而查询到的数据并不是最新的。

	--详情：
	著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)、P(分区容错性)
	1、Zookeeper保证的是CP，eureka保证的是AP。
	2、Zookeeper有leader和follower角色，eureka个节点平等
	3、Zookeeper采用过半数存活原则，eureka采用自我保护机制解决分区问题
	4、Eureka本质上是一个工程，而zookeeper只是一个进程。

	zookeeper保证CP：
		当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉。
		服务注册功能对可用性的要求高于一致性。但是zk会出现这样一种情况：当master节点因为网络故障与其它节点失去联系时，剩余节点会重新进行leader选举。由于选举master的时间太长，30~120s，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。
		在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。
	eureka保证AP：
		eureka在设计时优先保证可用性。eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余节点依然可以提供注册和查询服务。eureka客户端在向某个eureka注册时，如果发现连接失败，则会自动切换至其它节点，只要有一台eureka还在，就能保证注册服务可用（保证可用性），只不过查询的信息可能不是最新的（不保证强一致性）。
		除此之外，eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，eureka就会认位客户端与注册中心出现了网络故障，此时会出现以下几种情况：
			1、eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务；
			2、eureka仍然能够接收新的服务的注册和查询请求，但是不会被同步到其它节点上（保证当前节点仍然可用）
			3、当网络稳定时，当前实例新的注册信息会被同步到其它节点中
			因此，eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会向zookeeper那样使整个注册服务瘫痪。

	--Eureka的自我保护机制会出现以下情况：
		1、Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务
		2、Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)
		3、当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)
		Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪


Eureka和Consul的区别？
	Consul服务注册相比Eureka会稍慢一些。因为Consul的raft协议要求必须过半数的节点都写入成功才认为注册成功，Leader挂掉时，重新选举期间整个Consul不可用。Eureka服务注册快，但可能会出现数据不一致的情况。



*************************服务间通讯(Ribbon、Feign)*************************
服务与服务之间通讯：
	基于http restful的。
	spring cloud有两种调用方式：1、ribbon+restTemplate； 2、feign
	RestTemplate：用于进行http请求
负载均衡：
	描述：在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在SpringCloud可以用RestTemplate+Ribbon或Feign来调用。为了保证其高可用，单个服务通常会集群部署。将用户请求平摊分配到多个服务。
负载均衡调度算法：
	nginx：轮询、加权轮询
	Ribbon：轮询策略(RoundRobinRule)、随机策略(RandomRule)、重试


Ribbon介绍：
	构建过程：依赖eureka
	客户端首先引入eureka客户端组件，再从restTemplate的bean上加上@LoadBalanced注解，就可以用微服务的名称从eureka集群中获取服务列表，进而选出一台服务器。
	核心组件：IRule根据特定算法从服务列表中选取一个要访问的服务。自带7种均衡策略。默认轮询。
	修改默认策略：向容器中注册一个IRule的bean，这样ribbon就会使用用户自己的策略来覆盖默认策略。
	自定义策略：
		在主启动类上加@RibbonClient(name="服务名", configuration=XxxRuler.class)，从而在启动服务的时候就能去加载自定义的Ribbon配置类。
		代码中向容器注入自己的XxxRuler的bean.


Feign介绍：
	Feign是一个声明式WebSocket客户端。采用的是基于接口注解。
	SpringCloud对feign进行了封装，使其支持了SpringMVC标准注解和HttpMessageConverters。
	Feign整合了ribbon，并和eureka结合，默认实现了负载均衡的效果。Feign还具有熔断的能力。
	OpenFeign也是运行在消费者端的，使用Ribbon进行负载均衡，所以OpenFeign直接内置了Ribbon。

	--测试实例：
	@FeignClient(value = "eureka-client-provider") // 指定提供者的名字
	public interface TestClient {
	    // 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了
	    @PostMapping(value = "/provider/xxx")
	    CommonResponse<List<Plan>> getPlans(@RequestBody planGetRequest request);
	}

	@RestController
	public class TestController {
	    // 这里就相当于原来自动注入的 Service
	    @Autowired
	    private TestClient testClient;
	    // controller 调用 service 层代码
	    @RequestMapping(value = "/test", method = RequestMethod.POST)
	    public CommonResponse<List<Plan>> get(@RequestBody planGetRequest request) {
	        return testClient.getPlans(request);
	    }
	}

ribbon和feign的区别？
	Ribbon和feign都是客户端的负载均衡的工具，Feign的底层就是通过Ribbon实现的，它是对Ribbon的进一步的封装，让Ribbon更加好用。
	Ribbon是一个基于HTTP和TCP客户端的负载均衡器。它可以在客户端配置ribbonServerList（服务端列表），然后轮询请求以实现负载均衡。
	Feign是在Ribbon的基础上进行了一次封装，是一个使用起来更加方便的HTTP客户端，让调用者更像是调用一个本地方法一样调用远程服务。
	其中OpenFeign是在NetflixFeign的基础上扩展了对SpringMVC的注解支持，在新版本的SpringCloud中已经没有了对Feign的依赖集成。


*************************断路器（Hystrix）*************************
	功能：服务降级、服务熔断、服务限流、接近实时的监控。
	Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。

服务雪崩：
	出现原因：在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。


服务端服务熔断：
1.概念：
	熔断机制是应对雪崩效应的一个微服务链路保护机制。
	对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源，确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回，不会阻塞的。再等到目标服务好转后进行接口恢复。
	当链路中某个微服务不可用或响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，向调用方返回一个符合预期的、可处理的备选响应fallback，而不是长时间的等待或抛出调用方无法处理的异常，这样保证了服务调用方的线程不会被长时间、不必要占用，从而避免了故障在分布式系统中蔓延，乃至雪崩。当检测到该节点微服务调用响应正常后会恢复调用链路。
	hystrix会监控微服务间调用的状况，当失败的调用达到一定阈值，默认5秒20次调用失败就会启动熔断机制。

	多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的 “扇出” 。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.
2.实现步骤：
	1）主启动类添加@EnableCircuitBreaker注解。
	2）在@RequestMapping处增加@HystrixCommand（fallbackMethod="方法名"），新建一个出入参相同的类似方法，以便在原方法抛出异常时代替原方法。
	3）默认每次原方法抛出异常都会触发熔断。

客户端服务降级：
1.概念：
	整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再开启回来。它依赖Feign。
	当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
2.实现步骤：
	1）新建一个FallbackFactory接口的实现类，重写create方法。
	2）在@FeignClient注解中加fallbackFactory属性值。例如：@FeignClient(value="", fallbackFactory=xxxFallbackFactory.class)
	3）开启Feign对Hystrix的支持。在yml配置文件中配置feign.hystrix.enabled: true


需求描述：
	1、Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。
	2、但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！
	3、积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。

服务限流：
	详情：https://www.fangzhipeng.com/springcloud/2018/12/22/sc-f-gatway4.html
前言：
	每一个对外提供服务的API接口都是需要做流量控制的，不然会导致系统直接崩溃。原理跟保险丝一样，若用电符合超载就会烧断保险丝以达到保护的作用。API限流的意义也是如此，如果API上的流量请求超过核定的数值我们就对请求进行引流或直接拒绝等操作。
常见限流方式：
	Hystrix使用线程池隔离，超过线程池的负载，走熔断的逻辑。
	一般应用服务器中，如tomcat容器也是通过限制它的线程数来控制并发的。
常见限流维度：
	ip限流、uri限流、用户访问频次限流
限流算法：
	--1、漏桶算法：
		准备一个队列保存请求，通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。问题：可能无法应对短时间的突发流量
		漏桶可以看作是一个带有常量服务时间的单服务队列，如漏桶（包缓存）溢出，那么数据包会被丢弃。
		漏桶算法不能有效地使用网络资源，因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。
	--2、令牌算法：
		原理：系统会以一个恒定的速度往桶里面放入令牌，而如果请求需要被处理，则需要从桶里面获取一个令牌，当桶里面没有令牌可取时，则拒绝服务。
		准备一个队列保存请求，通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。问题：可能无法应对短时间的突发流量
	--区别：
		令牌桶里面装的是令牌，然后让令牌取关联到数据发送，常规漏桶里面装的是数据，令牌桶允许用户的正常持续突发量（BC），就是一次就将桶里面的令牌用尽的方式来支持续突发，而常规的漏桶则不允许用户任何突发行。
	3、另外：计数器算法：可能存在“突刺现象”


服务降级：
前言：
	服务降级，就是对不怎么重要的服务进行低优先级的处理。说白了，就是尽可能的把系统资源让给优先级高的服务。资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证网站核心功能服务的可用性，都要对某些服务降级处理。
服务降级方法：
	拒绝服务：
		判断应用来源，高峰时段拒绝低优先级应用的服务请求，保证核心应用正常工作。也可以随机拒绝请求，直接返回服务器繁忙，避免同时涌入过多的请求，这在电商秒杀时用的特别多。
	关闭服务：
		既然是高峰期，那么可以关闭一些冷门的或者边缘不重要的服务，给核心服务让出资源。如淘宝每年双11时候都会关闭如评价、确定收货等一些与下单核心业务无关的服务，以保证用户下单支付正常，当然肯定也会使用拒绝服务，0点高峰期很多用户看到的基本是服务器繁忙。

服务熔断:
	当调用目标服务的请求和调用大量超时或失败，服务调用方为避免造成长时间的阻塞造成影响其他服务，后续对该服务接口的调用不再经过进行请求，直接执行本地的默认方法。
	熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。
	在SpringCloud框架里熔断机制通过Hystrix或Resilience4j来实现。
服务降级：
	描述：当消费者调用提供者时由于各种原因出现无法调用的情况时，消费者可以进行服务降级。那么，若客户端通过网关调用消费者无法调用时，zuul具有服务降级功能。
	服务降级，当某个服务熔断之后，客户端将不再调用此请求，此时客户端返回一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。
服务限流:
	当系统资源不够，不足以应对大量请求，对系统按照预设的规则进行流量限制或功能限制。


*************************路由网关（zuul/gateway）*************************
描述：
	类似nginx反向代理的功能。在微服务架构中，后端服务往往不直接开放给调用者，而是通过访问统一入口（API网关）根据请求url，路由到相应的服务。
	比如安卓、ios、pc前端、小程序等客户端，不用去关心后端有几百个服务，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的个服务。
	作用：在网关处可以做统一的访问入口、负载均衡、降级、限流、安全认证授权等等。
	Spring Cloud中的网关有：Zuul和Spring Cloud Gateway，最新版本中推荐使用后者。


微服务架构流程：
	总体流程：服务网关、open-service和service
	1、服务网关、open-service和service启动时都注册到注册中心上去；
	2、用户请求时直接请求网关，网关做智能路由转发到open-service，这包括服务发现、负载均衡、权限校验、监控、限流等操作；
	3、open-service聚合内部service响应，返回给网关，网关再返回给用户。


什么是网关？
	服务网关 = 路由转发 + 过滤器
	路由转发：网关接收一切外界请求，转发到后端的微服务上
	过滤器：在服务网关中可以完成一系列横切功能，例如权限校验、限流及监控等。

服务网关基本功能：
	1、智能路由：接收外界一切请求，并转发到后端的对外服务open-service上去；
		附：我们只转发外部请求，服务之间的请求不走网关，这就表示全链路追踪、内部服务API监控、内部服务之间调用的容错、智能路由不能在网关完成；当然，也可以将所有的服务调用都走网关，那么几乎所有的功能都可以集成到网关中，但是这样的话，网关的压力会很大，不堪重负。
	2、权限校验：只校验向open-service服务的请求，不校验服务内部的请求；
	3、api监控：只监控经过网关的请求，以及网关本身的一些性能指标（如gc等）
	4、限流：与监控配合
	5、api日志统一收集

引入网关的注意点：
	1、增加了网关，就多了层转发（原本用户请求直接访问open-service即可），性能会下降一点（但下降不大，通过网关性能会很好，而且网关与open-service的访问通常是内网访问，速度很快）；
	2、网关的单点问题：在整个网络调用过程中，一定会有一个单点，可能是网关、nginx、dns服务器等。防止网关单点，可以在网关层前边再挂一台nginx，nginx的性能极高，基本不会挂。但是这样一个请求就转发了两次，所以最好的方式是网关单点服务部署在一台牛逼的机器上（通过压测来估算机器的配置），而且nginx与zuul的性能比较，根据国外的一个哥们儿做的实验来看，其实相差不大。
	3、网关要尽量轻。


*************************zuul*************************
zuul概述：
	主要功能：路由转发和过滤。zuul和eureka整合，会将zuul自身注册注册到Eureka中。
	请求路由：可作为外部访问统一入口，接收所有外部请求，再转发到具体的微服务实例上。
	过滤器：对请求的处理过程进行干预，可实现请求校验、服务聚合等功能。
	
使用步骤：
	1）添加Eureka和Zuu的maven依赖。
	2）主启动类上添加@EnableZuulProxy注解，无需@EnableDiscoveryClient注解。
	3）配置Eureka的相关配置信息。
	4）使用http://路由网关的ip+port/要请求的微服务名称/原微服务访问地址
	5）还可以将“微服务名称”进行映射。

功能：
1、统一前缀：
	直接调用服务消费者地址http://localhost:9000/consumer1/student/update；
	这时我们在zuul项目的配置文件中添加zuul.prefix=/zuul
	就需要通过http://localhost:9000/zuul/consumer1/student/update
2、路由策略配置：
	之前的访问方式会将微服务名称暴露给用户，会存在安全性问题，所以需要自定义路径来代替微服务名称，即自定义路由策略。
	zuul:
		routes:
			consumer1: /FrancisQ1/**
			consumer2: /FrancisQ2/**
	这时就可调用localhost:9000/zuul/FrancisQ1/student/update进行访问了。
3、服务名屏蔽：
	由于配置完路由策略之后，直接使用微服务名还是能访问的，这时候需要将服务名屏蔽掉。
	zuul:
		ignore-services: "*"
4、路径屏蔽：
	Zuul还可以指定屏蔽掉的路径URI，即只要用户请求中包含指定的URI路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。
	zuul:
		ignore-patterns: **/auto/**
5、敏感请求头屏蔽：
	默认情况下，像Cookie、Set-Cookie等敏感请求头信息会被zuul屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。
6、zuul过滤器：
	过滤器类型：Pre、Routing、Post。前置Pre就是在请求之前进行过滤，Routing路由过滤器就是我们上面所讲的路由策略，而Post后置过滤器就是在 Response 之前进行过滤的过滤器。
7、令牌桶限流：
	首先我们会有个桶，如果里面没有满那么就会以一定固定的速率会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么这个请求就拒绝，如果获取到那么就放行。

	实例：将请求数量控制在一秒两个。
	@Component
	@Slf4j
	public class RouteFilter extends ZuulFilter {
	    // 定义一个令牌桶，每秒产生2个令牌，即每秒最多处理2个请求
	    private static final RateLimiter RATE_LIMITER = RateLimiter.create(2);
	    @Override
	    public String filterType() {
	        return FilterConstants.PRE_TYPE;
	    }

	    @Override
	    public int filterOrder() {
	        return -5;
	    }

	    @Override
	    public Object run() throws ZuulException {
	        log.info("放行");
	        return null;
	    }

	    @Override
	    public boolean shouldFilter() {
	        RequestContext context = RequestContext.getCurrentContext();
	        if(!RATE_LIMITER.tryAcquire()) {
	            log.warn("访问量超载");
	            // 指定当前请求未通过过滤
	            context.setSendZuulResponse(false);
	            // 向客户端返回响应码429，请求数量过多
	            context.setResponseStatusCode(429);
	            return false;
	        }
	        return true;
	    }
	}



*************************配置中心（SpringCloud Config）*************************
	作用：配置管理。
	SpringCloudConfig提供服务端和客户端。服务端采用git存储配置信息，这样有助于对配置内容进行版本管理。每个微服务作为客户端
	服务端创建：
		1）在gitHub上建立一个仓库。
		2）创建一个微服务，主启动类上添加@EnableConfigServer注解。
		附：这个还是静态的，得配合SpringCloud Bus实现动态的配置更新。
概述：
	为微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。
	
	SpringCloud Config分为服务端和客户端两个部分。
	1、服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供配置信息，加密/解密信息等访问接口
	2、客户端通过指定配置中心来管理应用资源，以及与业务相关的配置内容，并在启动时从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样有利于对环境配置进行版本管理。


*************************消息总线(SpringCloud Bus)*************************
背景：我们有多个应用程序使用Spring Cloud Config读取属性，而Spring Cloud Config从git读取这些属性。假设git中eureka注册属性更改为指向另一台eureka服务器，这种情况下我们不得不重新启动服务已获取更新的属性。另一种使用执行器端点/刷新的方式，但是我们将不得不为每个模块单独调用这个url。

SpringCloud Bus通过轻量消息代理连接各个分布的节点。这回用在广播状态的变化（例如配置变化）或其它的消息指令。
SpringCloud Bus的一个核心思想是通过分布式的启动器对SpringBoot应用进行扩展，也可用来建立一个多个应用之间的通信频道

什么时候用cloud bus？
	1、更新动态IP：后端服务器集群时，在大促销活动经常发生服务的扩容、缩容、上线、下线。因而后端服务器的数量、IP就会变来变去，若想进行一些线上的管理和维护工作，就需要维护服务器的IP。
	2、失效所有机器的某缓存：比如我们需要更新配置、比如我们需要同时失效所有服务器上的某个缓存，都需要向所有的相关服务器发送命令，也就是调用一个接口。
	采用zookeeper方式，统一存储服务器的ip地址，需要的时候，向对应服务器发送命令。这是一个方案，但是他的解耦性、灵活性、实时性相比消息总线都差那么一点。
cloud bus能做什么？
	当前spring cloud bus提供了两个可用的接口:
		1./bus/env用于设置某一个配置项；
		2./bus/refresh用于刷新所有绑定到刷新点的配置项。




*************************链路追踪(SpringCloud Sleuth)*************************
	当我们项目中引入SpringCloudSleuth后，每次链路请求都会添加一串追踪信息。
	格式为[server-name, main-traceId, sub-spanId, boolean]
		server-name：服务节点名称
		main-traceId：一条链路唯一Id，为traceId
		sub-spanId：链路中每一环的Id，为SpanId
		boolean：是否将信息输出到Zipkin等服务收集和展示
	Sleuth的实现是基于http的，为了在数据的收集过程中不能影响到正常业务，Sleuth会在每个请求的Header上添加跟踪需求的重要信息。这样在数据收集时，只需将Header上的相关信息发送给对应的图像工具即可，图像工具根据上传的数据，按照Span对应的逻辑进行分析、展示。



*************************其它问题*************************
分布式锁：
	分布式锁（全局锁）实现：基于redis实现、基于Zookeeper实现、基于Consul实现
	--实例：基于Concul的分布式锁
	基于Consul的分布式锁主要利用key/value存储API中的acquire和release操作来实现。
	acquire操作：当锁不存在持有者时返回true，并且设值setValue，同时执行操作的session会持有对该key的锁，否则就返回false。
	release操作：使用指定session来释放某个key的锁，如果指定的session无效，则会返回false，否则就会设值setValue，并返回true。

分布式事务：
	在微服务架构下，能不使用分布式事务就尽量不要使用，如果一定要使用的话，目前主流的方案有三种：
	--1.二阶段提交 2PC，强一致性
	通过提交分阶段和记日志的形式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个阶段节点重试。
	--2.消息机制，最终一致性
	借助消息队列，在处理业务逻辑的地方，发送消息，业务逻辑处理成功后，提交消息，确保消息是发送成功的。之后消息队列投递来进行处理，如果成功，则结束，如果没有成功，则重试，直到成功。不过仅仅适用业务逻辑中，第一阶段成功，第二阶段必须成功的场景。
	--3.TCC补偿模式，最终一致性
	服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作反操作，恢复到未执行事务A前的状态。

微服务如何实现session共享？
	描述：在微服务中，一个完整的项目被拆分成多个不同的独立服务，各服务独立部署在不同的服务器上，各自的session被从物理空间上隔开了，但我们需要在不同微服务之间共享session。
	方案1：SpringSession+Redis实现session共享。
		将所有微服务的session统一保存在redis上，当各微服务对session有相关读写操作时，都去操作redis上的session。
	方案2：去session化，采用jwt保存用户基本信息。


