什么是微服务？
	微服务架构是一种架构模式，它提倡将单一应用程序划分为一组小的服务，每个服务运行在其独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价格。服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。
微服务的优缺点分别是什么？
	--微服务的优缺点分别是什么?说下你在项目开发中碰到的坑
	--优点：
	每一个服务足够内聚,代码容易理解
	开发效率提高,一个服务只做一件事
	微服务能够被小团队单独开发
	微服务是松耦合的,是有功能意义的服务
	可以用不同的语言开发,面向接口编程
	微服务只是业务逻辑的代码,不会和HTML,CSS或者其他界面组合
	可以灵活搭配,连接公共库/连接独立库
	--缺点：
	分布式系统的负责性
	多服务运维难度,随着服务的增加,运维的压力也在增大
	系统部署依赖
	服务间通信成本
	数据一致性

集中式系统和分布式系统:
	-1）集中式系统：一个主机带多个终端（如浏览器），终端没有数据处理能力，仅负责数据的录入和输出，而运算、存储等全部在主机上运行。
	-2）分布式系统：把一个计算任务分解为若干个计算单元，并分派到若干个不同的计算机中去执行，然后再汇总计算结果。
	附：终端（terminal），也称终端设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入及处理结果的输出等。

分布式和集群的区别：
	-1）分布式（distributed）：指多台不同的服务器中部署不同的服务模块，通过远程调用协同工作，对外提供服务
	-2）集群（cluster）：指在多台不同的服务器中部署相同的应用或服务模块，构成一个集群，通过负载均衡设备对外提供服务。

spring、springboot、SpringCloud关系？
	1、Spring两大核心功能IOC和AOP。
	2、springboot在spring生态基础上发展而来，它的出现是为了更容易的使用Spring。
	3、springCloud是一系列框架的有序集合。它利用Springboot的开发便利性，巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Springboot的开发风格做到一键启动和部署。
	SpringBoot是快速开发工具，专注于应用个体；SpringCloud基于SpringBoot开发，因此继承了SpringBoot的特性，其更专注于服务治理。
SpringBoot和SpringCloud
	SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,旨在快速搭建单个微服务
	SpringCloud专注于解决各个微服务之间的协调与配置,服务之间的通信,熔断,负载均衡等
	技术维度并相同,并且SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发。
	--总结：
	SpringBoot专注于快速方便的开发单个个体的微服务
	SpringCloud是关注全局的微服务协调整理治理框架,整合并管理各个微服务,为各个微服务之间提供,配置管理,服务发现,断路器,路由,事件总线等集成服务
	SpringBoot不依赖于SpringCloud,SpringCloud依赖于SpringBoot,属于依赖关系
	SpringBoot专注于快速,方便的开发单个的微服务个体,SpringCloud关注全局的服务治理框架


SpringCloud和dubbo区别？
	dubbo专注于RPC框架，其它的分布式技术需要依赖第三方技术来组装出一个分布式架构。现已弃用。
	springCloud是一站式服务，提供了所有分布式架构需要的技术，不用依赖其它第三方技术，所以各组件间的兼容性很好。各服务间调用使用http协议。

	Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。
	Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。

	1、SpringCloud和Dubbo都是现在主流的微服务架构。
	2、SpringCloud是Apache旗下的Spring体系下的微服务解决方案；Dubbo是阿里系的分布式服务治理框架从技术维度上,其实SpringCloud远远的超过Dubbo,Dubbo本身只是实现了服务治理,而SpringCloud现在以及有21个子项目以后还会更多。
	3、服务的调用方式Dubbo使用的是RPC远程调用,而SpringCloud使用的是 Rest API,其实更符合微服务官方的定义。
	4、服务的注册中心来看,Dubbo使用了第三方的ZooKeeper作为其底层的注册中心,实现服务的注册和发现,SpringCloud使用Spring Cloud Netflix Eureka实现注册中心,当然SpringCloud也可以使用ZooKeeper实现,但一般我们不会这样做
	服务网关,Dubbo并没有本身的实现,只能通过其他第三方技术的整合,而SpringCloud有Zuul路由网关,作为路由服务器,进行消费者的请求分发,SpringCloud还支持断路器,与git完美集成分布式配置文件支持版本控制,事务总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素

rest和rpc的区别？
	rest风格的系统交互更方便，rpc调用服务提供方和调用方式之间依赖太强。
	rest调用系统性能较低，rpc调用效率比rest高。
	rest的灵活性可以跨系统跨语言调用，rpc只能在同语言内调用。
	rest可以和swagger等工具整合，自动输出接口api文档。

	1、如果仔细阅读过微服务提出者马丁福勒的论文的话可以发现其定义的服务间通信机制就是http rest。
	2、rpc最主要的缺陷就是服务提供方和调用方式之间依赖太强,我们需要为每一个微服务进行接口的定义,并通过持续继承发布,需要严格的版本控制才不会出现服务提供和调用之间因为版本不同而产生的冲突
	3、而rest是轻量级的接口,服务的提供和调用不存在代码之间的耦合,只是通过一个约定进行规范,但也有可能出现文档和接口不一致而导致的服务集成问题,但可以通过swagger工具整合,是代码和文档一体化解决,所以rest在分布式环境下比rpc更加灵活这也是为什么当当网的dubbox在对dubbo的增强中增加了对rest的支持的原因


总结：
	Eureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
	Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台
	Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
	Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
	Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务



概述：
	SpringCloud是基于SpringBoot的分布式微服务框架，为开发人员提供分布式服务的相关技术模块。如服务注册与发现(注册中心和服务提供者)、服务消费者(负载均衡)、熔断器、配置管理、消息总线、路由网关、服务追踪等。
微服务系统描述：
	在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在SpringCloud可以用RestTemplate+Ribbon和Feign来调用。
	客户端的请求首先通过负载均衡（zuul、nginx），再到达服务网关（zuul集群、SpringCloudGateway），然后再到具体的服务。
	服务统一注册到高可用的服务注册中心集群，服务的所有配置文件由配置服务管理，配置服务的配置文件放在git仓库。

配置方案：
	1、将整个系统按业务拆分成若干子系统或微服务，且每个子系统可部署多个应用，多个应用间使用负载均衡。
	2、需要一个注册中心(Eureka Server)，所有服务都将注册到注册中心。注册中心可部署多个，以保证高可用。
	3、所有服务(EurekaClient)都统一注册到注册中心，服务之间采用feign/feign进行调用。每个服务可配置多个，调用同一服务可按照一定策略来实现负载均衡。
	3、所有客户端都通过统一网地址访问后台的服务，通过路由配置zuul或gwteway网关来判断一个url请求由哪个服务处理。请求转发到服务上的时候使用负载均衡Ribbon/feign。
	5、使用断路器 hystrix，及时处理服务调用时的超时和错误，防止由于其中一个服务的问题而导致整体系统的瘫痪。
	6、还需要一个监控功能，监控每个服务调用花费的时间等。
	7、使用 SpringCloud Config 进行统一的配置管理，对所有服务的配置资源统一管理。
	8、Hystrix，监控和断路器。我们只需要在服务接口上添加 Hystrix 标签，就可以实现对这个接口的监控和断路器功能。
	9、Hystrix Dashboard，监控面板，他提供了一个界面，可以监控各个服务上的服务调用所消耗的时间等。
	10、Turbine，监控聚合，使用 Hystrix 监控，我们需要打开每一个服务实例的监控信息来查看。而Turbine可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。这样就不需要挨个打开一个个的页面一个个查看。

常用组件：
	分布式微服务--SpringCLoud、Dubbo
	服务注册发现--Eureka、consul、zk、nacos
	客户端负载均衡--ribbon
	服务调用--feign
	断路器--Hystrix
	服务网关--Zuul
	分布式配置中心--SpringCloudConfig
	事件消息总线--Spring Cloud Bus

	服务的配置与管理 ： netfix 公司 archaius 阿里的diamond等
	服务的注册于发现 ：spriing cloud 所采用的 eureka ，consul,zookeeper 等
	服务的调用:rest GRPC RPC 
	服务的熔断器 ：hystrix envoy等
	负载均衡 ：ribbon .nginx
	服务接口调用(客户端调用服务的简化工具) Feign等消息队列Kafka、 Rabbitmq、 Activemq等
	服务配置中心管理Spring Cloud Config、Chef等服务路由(API网关)Zuu等
	服务监控Zabbix、 Nagios、 Metrics、 Spectator等
	全链路追踪Zipkin, Brave、 Dapper等
	服务部罟Docker、 Open Stack、 Kubernetes等
	数据流操作开发包--Spring Cloud Stream(封装redis,rabbit,kafka等发送接收消息)
说明：
	1）eureka
		包括注册中心(eureka server)和服务提供者(eureka client)
		各服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
	2）ribbon+restTemplate 2、feign --服务消费者、服务与服务之间负载均衡	
	3）Hystrix：熔断器
		测试：1、ribbon使用断路器hystrix 2、feign自带断路器 3、监控工具Hystrix-Dashboard
	4）Config：配置中心。配置文件统一管理。
	5）Zuul/gateway：路由转发和过滤器、网关。
		若前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务
		zuul默认和Ribbon结合实现了负载均衡的功能。比如／api/user转发到到user服务，/api/shop转发到到shop服务。


*************************服务注册与发现(Eureka)*************************
服务注册和发现是什么？SpringCloud如何实现？
	详情：https://www.iteye.com/blog/yangyangmyself-2334788 ！！
	详情：http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/
	答案：https://zhuanlan.zhihu.com/p/99164801?utm_source=qq&utm_medium=social&utm_oi=965555060286144512

1.概念
	SpringCloudEureka是SpringCloudNetflix项目下的服务治理模块，基于rest服务，用于定位服务，以实现云端中间件服务发现和故障转移。对微服务架构而言，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件。功能类似于dubbo的注册中心，比如zookeeper。
	rureka由两个组件组成：Eureka服务端和Eureka客户端。Eureka服务端用于服务注册中心，支持集群部署。

	Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。 而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行
2.原理
	系统的其它微服务，使用eureka客户端连接到eureka服务端并维持心跳连接。这样就能通过eureka服务端来监控系统中各微服务是否正常运行。SpringCloud的一些其它模块（如zuul）就可以通过eurekaServer来发现系统中的其它服务，并执行相关的逻辑。
3.eureka包含两个组件：服务端(eureka server)和客户端(eureka client)
	eureka server提供服务注册服务，支持集群部署。
	各个节点启动后，会在eurekaServer中进行注册，这样eurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。

	eureka客户端是一个java客户端，用于处理服务注册与发现。
	eureka客户端同时也具备了一个内置的、使用轮询(round-robin)负载均衡器。在应用启动后，将会想eurekaServer发送心跳（默认周期为30秒）。若eurekaServer在多个心跳周期内没有接收到某个节点的心跳，eurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）

	三大角色：
	注册中心(eureka server)：提供服务注册与发现；
	服务提供者(service provider)：将自身服务注册到eureka，从而使服务消费方能够找到；
	服务消费者(service consumer)：从eureka获取注册服务列表，从而能够消费服务。

	eurekaServer集群配置(applicaion.yml):
	server:
		port: 7001
	eureka:
		instance:
			hostname:eureka_server
		client:
			register-with-eureka: false #false表示不再向注册中心注册自己
			fetch-register: false #false表示自己是注册中心
			service-url:
				#设置与eureka Server交互的地址查询服务和注册都需要依赖这个地址
				#defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #单机
				defaultZone: http://eureka1001:1001/eureka/,http://eureka1002:1002/eureka/ #集群


4.Eureka续约与剔除：
	服务实例启动后，会周期性地向 Eureka Server发送心跳以续约自己的信息，避免自己的注册信息被剔除。续约的方式与服务注册基本一致：首先更新自身状态，再同步到其它Peer。
	如果Eureka Server在一段时间内没有接收到某个微服务节点的心跳，Eureka Server将会注销该微服务节点（自我保护模式除外）


5.自我保护模式：
	需求描述：默认情况下，若eurekaServer在一定时间内没有收到某个微服务实例的心跳，eurekaServer将会注销该实例（默认90秒）。但当网络分区故障发生时，微服务与eurekaServer之间无法正常通信，以上行为可能变得非常危险了--因为微服务本身其实健康的，此时本不应该注销该服务实例。
	
	默认情况下，如果Eureka Server在90s内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，导致此实例被注销。
	
	当Eureka Server检测到大规模服务异常时，会自动进入自我保护机制：
		Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。
		Eureka仍然能够接收新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）。
		当网络稳定时，当前实例新的注册信息会被同步到其他节点中。

	解决：eureka通过“自我保护模式”来解决这个问题--当eurekaServer节点在短时间内丢失过多客户端时（可能发生网络分区故障），那么该节点就会进入自我保护模式。一旦进入该模式，eurekaServer就会保护服务注册表的信息，不在删除服务注册表中的数据（也就是不会注销任何微服务）。但网路故障恢复后，该eurekaServer节点会自动退出自我保护模式。
	在自我保护模式中，eurekaServer会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳重新恢复到阈值以上时，该eurekaServer节点就会自动退出自我保护模式。这样设计是为了宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。


Eureka注册中心、服务提供者、服务消费者：
	1、注册中心(eureka server)：
		在启动类上添加@EnableEurekaServer注解，表明自己是一个eurekaServer。
	2、服务提供者(eureka client)：
		当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。服务注册中心从每个client实例接收心跳消息。如果心跳超时，则通常将该实例从注册server中删除。
	3、服务消费者(ribbon/feign)：
		在微服务架构中，业务都会拆分成一个独立的服务，服务与服务的通讯是基于http restful的。
		Spring Cloud有两种服务调用方式：1）ribbon+restTemplate，2）feign。
		ribbon是一个负载均衡客户端，可以很好的控制http和tcp的一些行为。Feign默认集成了ribbon。


1）服务注册中心(eureka服务端)：
	所有微服务集群都可以是它的客户端，来注册和订阅。
	启动：需要依赖spring-cloud-starter-eureka-server，并将主启动类标识@EnableEurekaServer。在yml配置文件中配置自己的访问地址等信息。默认情况下eureka server也是一个eureka client，必须要指定一个server。
	自我保护策略：在短时间内大量微服务没有心跳服务，会开启保护模式，不会立即删除注册表中没有心跳的微服务。当心跳回到阈值时会自动关闭保护模式。
	为什么需要自我保护策略？答：短时间内大量微服务没有心跳可能原因是注册中心网络中断了，无法与大部分服务连接。
2）服务注册(服务消费者)：
	启动：需要依赖spring-cloud-starter-netflix-eureka-client，并将主启动类标识@EnableEurekaClient，在yml配置文件中指定注册中心的访问地址等信息，这样本服务启动后会自动注册进eureka服务注册中心中。
	每个服务单元向注册中心登记自己提供的服务，将主机、端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单。
3）服务发现(服务消费者)：
	@EnableDiscoveryClient 本应用的主启动类上添加此注解表示：服务发现。进而可以在所有bean中使用DiscoveryClient接口来访问Eureka.或结合RestTemplate来访问Restful风格的http服务。
4）Eureka集群：
	各Eureka相互知晓。每个客户端要知晓所有Eureka，类似RocketMQ的NameServer。
5）与Zookeeper比较：
	eureka有自我保护机制。没有主从概念。
	zookeeper出现网络故障时会花30-120s来选举新master，而导致注册中心不可用，可用性不好。


6.与zookeeper对比
	著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)、P(分区容错性)
	1、zookeeper保证的是CP，eureka保证的是AP。
	2、zookeeper有leader和follower角色，eureka个节点平等
	3、zookeeper采用过半数存活原则，eureka采用自我保护机制解决分区问题
	4、eureka本质上是一个工程，而zookeeper只是一个进程。

	ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的。
	Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的

	zookeeper保证CP：
		当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉。
		服务注册功能对可用性的要求高于一致性。但是zk会出现这样一种情况：当master节点因为网络故障与其它节点失去联系时，剩余节点会重新进行leader选举。由于选举master的时间太长，30~120s，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。
		在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。
	eureka保证AP：
	eureka在设计时优先保证可用性。eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余节点依然可以提供注册和查询服务。eureka客户端在向某个eureka注册时，如果发现连接失败，则会自动切换至其它节点，只要有一台eureka还在，就能保证注册服务可用（保证可用性），只不过查询的信息可能不是最新的（不保证强一致性）。
	除此之外，eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，eureka就会认位客户端与注册中心出现了网络故障，此时会出现以下几种情况：
		1、eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务；
		2、eureka仍然能够接收新的服务的注册和查询请求，但是不会被同步到其它节点上（保证当前节点仍然可用）
		3、当网络稳定时，当前实例新的注册信息会被同步到其它节点中
		因此，eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会向zookeeper那样使整个注册服务瘫痪。

	--Eureka的自我保护机制会出现以下情况：
		1、Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务
		2、Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)
		3、当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)
		Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪

7.Eureka和Consul的区别
	Consul服务注册相比Eureka会稍慢一些。因为 Consul的raft协议要求必须过半数的节点都写入成功才认为注册成功，Leader挂掉时，重新选举期间整个Consul不可用。Eureka服务注册快，但可能会出现数据不一致的情况。



*************************Ribbon、Feign*************************
服务与服务之间通讯：
	基于http restful的。
	spring cloud有两种调用方式：1）ribbon+restTemplate 2）feign

ribbon


feign
	feign是一个声明式WebSocket客户端。
	SpringCloud对feign进行了封装，使其支持了SpringMVC标准注解和HttpMessageConverters。

Ribbon和Feign的区别：
	Ribbon是一个基于HTTP和TCP客户端的负载均衡器。它可以在客户端配置ribbonServerList（服务端列表），然后轮询请求以实现负载均衡。
	Feign是在Ribbon的基础上进行了一次封装，是一个使用起来更加方便的HTTP客户端，让调用者更像是调用一个本地方法一样调用远程服务。
	其中OpenFeign是在NetflixFeign的基础上扩展了对SpringMVC的注解支持，在新版本的SpringCloud中已经没有了对Feign的依赖集成。
ribbon和 feign 的区别？
	1、Ribbon 和 feign 都是客户端的负载均衡的工具，Feign的底层就是通过Ribbon实现的，它是对Ribbon的进一步的封装，让Ribbon 更加好用。
	2、Ribbon 使用HttpClient 或 RestTemplate 模拟http请求，步骤相当繁琐。而Feign采用接口+注解的方式 ，将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写 客户端变得非常容易。类似于 mybatis 的 @Mapper注解 。



负载均衡（Ribbon、Feign）
	出现原因：在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在SpringCloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。将用户请求平摊分配到多个服务。
	1）Ribbon：
		构建过程：依赖eureka
		客户端首先引入eureka客户端组件，再从restTemplate的bean上加上@LoadBalanced注解，就可以用微服务的名称从eureka集群中获取服务列表，进而选出一台服务器。
		核心组件：IRule根据特定算法从服务列表中选取一个要访问的服务。自带7种均衡策略。默认轮询。
		修改默认策略：向容器中注册一个IRule的bean，这样ribbon就会使用用户自己的策略来覆盖默认策略。
		自定义策略：
			在主启动类上加@RibbonClient(name="服务名", configuration=XxxRuler.class)，从而在启动服务的时候就能去加载自定义的Ribbon配置类。
			代码中向容器注入自己的XxxRuler的bean.
	2）feign描述：
		feign是一个声明式的伪http客户端。feign采用的是基于接口注解。
		Feign 整合了ribbon，并和eureka结合，默认实现了负载均衡的效果。Feign还具有熔断的能力。





*************************断路器（Hystrix）*************************
	功能：服务降级、服务熔断、服务限流、接近实时的监控。
	Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。

服务雪崩：
	出现原因：在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用，在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。

服务端服务熔断
1.概念：
	熔断机制是应对雪崩效应的一个微服务链路保护机制。
	对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源，确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回，不会阻塞的。再等到目标服务好转后进行接口恢复。

	当链路中某个微服务不可用或响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，向调用方返回一个符合预期的、可处理的备选响应fallback，而不是长时间的等待或抛出调用方无法处理的异常，这样保证了服务调用方的线程不会被长时间、不必要占用，从而避免了故障在分布式系统中蔓延，乃至雪崩。当检测到该节点微服务调用响应正常后会恢复调用链路。
	hystrix会监控微服务间调用的状况，当失败的调用达到一定阈值，默认5秒20次调用失败就会启动熔断机制。

	多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的 “扇出” 。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.
2.实现步骤：
	1）主启动类添加@EnableCircuitBreaker注解。
	2）在@RequestMapping处增加@HystrixCommand（fallbackMethod="方法名"），新建一个出入参相同的类似方法，以便在原方法抛出异常时代替原方法。
	3）默认每次原方法抛出异常都会触发熔断。

客户端服务降级
1.概念：
	整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再开启回来。它依赖Feign。
	当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
2.实现步骤：
	1）新建一个FallbackFactory接口的实现类，重写create方法。
	2）在@FeignClient注解中加fallbackFactory属性值。例如：@FeignClient(value="", fallbackFactory=xxxFallbackFactory.class)
	3）开启Feign对Hystrix的支持。在yml配置文件中配置feign.hystrix.enabled: true
	

需求描述：
	1、Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。
	2、但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！
	3、积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。


限流：
	详情：https://www.fangzhipeng.com/springcloud/2018/12/22/sc-f-gatway4.html
常见限流方式：
	Hystrix使用线程池隔离，超过线程池的负载，走熔断的逻辑。
	一般应用服务器中，如tomcat容器也是通过限制它的线程数来控制并发的。
常见限流维度：
	ip限流、uri限流、用户访问频次限流
常见限流算法：
	1、计数器算法：可能存在“突刺现象”
	2、漏桶算法：准备一个队列保存请求，通过一个线程池（ScheduledExecutorService）来定期从队列中获取请求并执行，可以一次性获取多个并发执行。问题：可能无法应对短时间的突发流量
	3、令牌桶算法：准备一个队列保存令牌，通过一个线程池定期生成令牌放队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。


服务熔断和服务降级：
	熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix或Resilience4j来实现。
	
	服务降级，当某个服务熔断之后，客户端将不再调用此请求，此时客户端返回一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。



*************************路由网关（zuul/gateway）*************************
	描述：类似nginx反向代理的功能。在微服务架构中，后端服务往往不直接开放给调用者，而是通过访问统一入口（API网关）根据请求url，路由到相应的服务。
	比如安卓、ios、pc前端、小程序等客户端，不用去关心后端有几百个服务，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的个服务。
	作用：在网关处可以做统一的访问入口、负载均衡、降级、限流、安全认证授权等等。

服务网关的作用：
	简化客户端调用复杂度，统一处理外部请求。
	数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。
	多渠道支持，针对不同的客户端提供不同的网关支持。
	遗留系统的微服务化改造，可以作为新老系统的中转组件。
	统一处理调用过程中的安全、权限问题。
	Spring Cloud中的网关有：Zuul和Spring Cloud Gateway，最新版本中推荐使用后者。

1.zuul概述：
	zuul包含了对请求的路由和过滤两个功能。
	路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础。
	过滤器负责对请求的处理过程进行干预，可实现请求校验、服务聚合等功能。
	zuul和eureka整合，将zuul自身注册为eureka服务治理下的应用，同时从eureka中获得其它微服务的消息，即以后的访问微服务都是通过zuul跳转后获得。


zuul描述：
	路由和过滤的作用。也是一个微服务集群，也需要注册到Eureka中。
	可以设置统一的访问入口，所有服务都可以通过它来间接访问。
	--使用步骤：
	1）添加Eureka和Zuu的maven依赖。
	2）主启动类上添加@EnableZuulProxy注解，无需@EnableDiscoveryClient注解。
	3）配置Eureka的相关配置信息。
	4）使用http://路由网关的ip+port/要请求的微服务名称/原微服务访问地址
	5）还可以将“微服务名称”进行映射。


*************************配置中心（Config）*************************
	作用：配置管理。
	SpringCloudConfig提供服务端和客户端。服务端采用git存储配置信息，这样有助于对配置内容进行版本管理。每个微服务作为客户端
	服务端创建：
		1）在gitHub上建立一个仓库。
		2）创建一个微服务，主启动类上添加@EnableConfigServer注解。
		附：这个还是静态的，得配合SpringCloud Bus实现动态的配置更新。
概述：
	为微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。
	
	SpringCloud Config分为服务端和客户端两个部分。
	1、服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供配置信息，加密/解密信息等访问接口
	2、客户端通过指定配置中心来管理应用资源，以及与业务相关的配置内容，并在启动时从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样有利于对环境配置进行版本管理。


*************************消息总线(SpringCloud Bus)*************************
	背景：我们有多个应用程序使用Spring Cloud Config读取属性，而Spring Cloud Config从git读取这些属性。假设git中eureka注册属性更改为指向另一台eureka服务器，这种情况下我们不得不重新启动服务已获取更新的属性。另一种使用执行器端点/刷新的方式，但是我们将不得不为每个模块单独调用这个url。

	SpringCloud Bus通过轻量消息代理连接各个分布的节点。这回用在广播状态的变化（例如配置变化）或其它的消息指令。
	SpringCloud Bus的一个核心思想是通过分布式的启动器对SpringBoot应用进行扩展，也可用来建立一个多个应用之间的通信频道


*************************链路追踪(SpringCloud Sleuth)*************************
	当我们项目中引入SpringCloudSleuth后，每次链路请求都会添加一串追踪信息。
	格式为[server-name, main-traceId, sub-spanId, boolean]
		server-name：服务节点名称
		main-traceId：一条链路唯一Id，为traceId
		sub-spanId：链路中每一环的Id，为SpanId
		boolean：是否将信息输出到Zipkin等服务收集和展示
	Sleuth的实现是基于http的，为了在数据的收集过程中不能影响到正常业务，Sleuth会在每个请求的Header上添加跟踪需求的重要信息。这样在数据收集时，只需将Header上的相关信息发送给对应的图像工具即可，图像工具根据上传的数据，按照Span对应的逻辑进行分析、展示。



*************************Zookeeper*************************
概述：
	Zookeeper是一个开源的分布式协调服务，由雅虎创建，是Google Chubby的开源实现。分布式应用程序可以基于Zookeeper实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、配置维护、名字服务、分布式同步、分布式锁和分布式队列等功能。
核心概念：
	--1）集群角色
	在Zookeeper中有三种角色：Leader、Follower、Observer
	一个Zookeeper集群同一时刻只会有一个Leader，其它都是Follower或Observer。
	Zookeeper默认只有Leader和Follower两种角色，没有Observer角色。
	
	--2）节点读写服务分工：
	Zookeeper集群的所有机器通过一个Leader选举过程来选定一台被称为“Leader”的机器，Leader服务器为客户端提供读和写服务。
	Follower和Observer都能提供读服务，不能提供写服务。两者唯一的却别在于，Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。
	
	--3）Session：
	Session是指客户端会话。在Zookeeper中，一个客户端连接是指客户端和Zookeeper服务器之间的TCP长连接。
	ZooKeeper对外的服务端口默认是2181，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测和服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接收响应，同时还能通过该连接接收来自服务器的watch事件通知。
	Session的SessionTimeout值用来设值一个客户端会话的超时时间。当由于服务器压力太大、网络故障或客户端主动断开连接等各种原因导致客户端连接断开时，只要在SessionTimeout规定的事件内能重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。

	--4）数据节点：
	ZooKeeper结构其实就是一个树形结构，Leader是根节点，其它节点相当于Follower节点。
	ZooKeeper节点分两类：
		-1）持久节点：
		-2）临时节点：其生命周期跟客户端会话绑定，一旦客户端会话失效，那么该客户端所创建的所有临时节点都会被移除。

	--5）状态信息：
	每个节点除了存储数据内容之外，还存储了节点本身的一些状态信息。用get命令可以同时获得某个节点的内容和状态信息。
	在ZooKeeper中，version属性是用来实现乐观锁机制中的“写入校验”的。

	--6）事务操作：
	在ZooKeeper中，能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点创建和删除、数据内容更新和客户端会话创建与失效等操作。对应每一个事务请求，ZooKeeper都会为其分配一个全局唯一的事务ID，用ZXID表示，通常是一个64位的数字。每一个ZXID对应一次更新操作，从这些ZXID中可以间接地识别出ZooKeeper处理这些事务操作请求的全局顺序。

	--7）Watcher（事件监听器）：
	ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去。该机制是ZooKeeper实现分布式协调服务的重要特性。

应用场景：
	ZooKeeper是一个高可用的分布式数据管理与协调框架。基于对ZAB算法的实现，该框架能够很好地保证分布式环境中数据的一致性。也基于这样的特性，使得ZooKeeper成为了解决分布式一致性问题的利器。
1.数据发布与订阅（配置中心）：
	数据发布与订阅，即所谓的配置中心，即发布者将数据发布到ZooKeeper节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和动态更新。

	发布/订阅系统一般有两种设计模式：
		-1）推模式（Push）：服务端主动将数据更新发送给所有订阅的客户端。
		-2）拉模式（Pull）：客户端主动发起请求来获取最新数据，通常客户端都采用定时轮询拉取的方式。

	ZooKeeper采用的是推拉相结合的方式：
		客户端想服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务端就会向相应的客户端发送Watcher事件通知，客户端接收到这个消息通知后，需要主动到服务端获取最新的数据。

2.命名服务
	在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等。--这些我们都可以统称他们的名字。
	ZooKeeper的命名服务即生成全局唯一的ID。

3.分布式协调服务/通知
	ZooKeeper中特有的Watcher注册与异步通知机制，能够很好的实现分布式环境下不同机器，甚至不同系统之间的通知与协调，从而实现对数据变更的实时处理。使用方法通常是不同的客户端。
	如果及其节点发生了变化，那么所有订阅的客户端都能够受到相应的Watcher通知，并做出相应的处理。
	ZooKeeper的分布式协调/通知，是一种通用的分布式系统机器间的通信方式。

4.Master选举
	针对Master选举的需求，通常情况下，我们可以选择常见的关系型数据库中的主键特性来实现：希望成为Master的机器都向数据库中插入一条相同主键Id的记录，数据库回帮我们进行主键冲突检查，即只有一台机器能插入成功，该机器就是Master。

	利用ZooKeepr的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即ZooKeeper将会保证客户端无法创建一个已经存在的 数据单元节点。

	也就是说，如果同时有多个客户端请求创建同一个临时节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行 Master 选举了。
5.分布式锁
	分布式锁是控制分布式系统之间同步访问共享资源的一种方式。
	分布式锁分类：
		--1）排它锁
		定义锁：ZooKeepr上的一个机器节点可以表示一个锁
		获得锁：把ZooKeepr上的一个节点看作是一个锁，获得锁就通过创建心事节点的方式来实现。ZooKeeper 会保证在所有客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获得了锁。同时，所有没有获取到锁的客户端就需要到/exclusive_lock节点上注册一个子节点变更的Watcher监听，以便实时监听到lock节点的变更情况。
		释放锁：因为锁是一个临时节点，释放锁有两种方式。1.当前获得锁的客户端机器发生宕机或重启，那么该临时节点就会被删除，释放锁；2. 正常执行完业务逻辑后，客户端就会主动将自己创建的临时节点删除，释放锁。

		--2）共享锁：



















*************************其它*************************
分布式锁：
	分布式锁（全局锁）实现：基于redis实现、基于Zookeeper实现、基于Consul实现
	--实例：基于Concul的分布式锁
	基于Consul的分布式锁主要利用key/value存储API中的acquire和release操作来实现。
	acquire操作：当锁不存在持有者时返回true，并且设值setValue，同时执行操作的session会持有对该key的锁，否则就返回false。
	release操作：使用指定session来释放某个key的锁，如果指定的session无效，则会返回false，否则就会设值setValue，并返回true。


微服务如何实现session共享？
	描述：在微服务中，一个完整的项目被拆分成多个不同的独立服务，各服务独立部署在不同的服务器上，各自的session被从物理空间上隔开了，但我们需要在不同微服务之间共享session。
	方案：SpringSession+Redis实现session共享。
		将所有微服务的session统一保存在redis上，当各微服务对session有相关读写操作时，都去操作redis上的session。



分布式事务：
	在微服务架构下，能不使用分布式事务就尽量不要使用，如果一定要使用的话，目前主流的方案有三种：
	--1.二阶段提交 2PC，强一致性
	通过提交分阶段和记日志的形式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个阶段节点重试。
	--2.消息机制，最终一致性
	借助消息队列，在处理业务逻辑的地方，发送消息，业务逻辑处理成功后，提交消息，确保消息是发送成功的。之后消息队列投递来进行处理，如果成功，则结束，如果没有成功，则重试，直到成功。不过仅仅适用业务逻辑中，第一阶段成功，第二阶段必须成功的场景。
	--3.TCC补偿模式，最终一致性
	服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作反操作，恢复到未执行事务A前的状态。




RestTemplate：用于进行http请求

扛住阿里双十一高并发流量，Sentinel是怎么做到的？
	Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景
	名词解释：
		1、服务熔断:当调用目标服务的请求和调用大量超时或失败，服务调用方为避免造成长时间的阻塞造成影响其他服务，后续对该服务接口的调用不再经过进行请求，直接执行本地的默认方法
		2、服务限流:当系统资源不够，不足以应对大量请求，对系统按照预设的规则进行流量限制或功能限制
		3、服务降级:为了保证核心业务在大量请求下能正常运行，根据实际业务情况及流量，对部分服务降低优先级，有策略的不处理或用简单的方式处理
	服务降级的实现可以基于人工开关降级（秒杀、电商大促等）和自动检测（超时、失败次数、故障），熔断可以理解为一种服务故障降级处理









