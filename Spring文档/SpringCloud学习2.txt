
************************Eureka************************
	详情：https://zhuanlan.zhihu.com/p/105656533?utm_source=qq&utm_medium=social&utm_oi=965555060286144512
服务注册(Register):
	当eureka客户端向eurekaServer注册时，它提供自身的元数据，如ip地址、端口、运行状况指示符url、主页等。
服务续约(Renew):
	eureka客户端默认会每隔30s发送一次心跳来续约。通过续约l来告知eurekaServer该eureka客户端仍然存在，没有问题。正常情况下，如果eurekaServer在90s没有收到eureka客户的续约，它会将该实例从其注册表中删除。
获取注册表信息(Fetch Register):
	eureka客户端从服务器获取注册信息并将其缓存在本地。客户端会使用该信息查询对应服务，从而进行远程调用。该注册列表信息定期（每隔30s）更新一次。每次返回注册列表信息可能与eureka客户端的缓存信息不同，eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，eureka客户端则会重新获取整个注册表信息。eureka服务器缓存注册列表信息，整个注册表及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。
服务下线(Cancel):
	eureka客户端在程序关闭时向eureka服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。
	该下线请求不会自动完成，它需要调用：DiscoveryManager.getInstance().shutdownComponent();
服务剔除(Eviction):
	在默认的情况下，当eureka客户端连续90s（3个续约周期）没有向eureka服务器发送服务续约，即心跳，eureka服务器会将该服务实例从服务注册表删除。



************************Ribbon************************
负载均衡调度算法：
	nginx：轮询、加权轮询
	Ribbon：轮询策略(RoundRobinRule)、随机策略(RandomRule)、重试




************************OpenFeign************************
	OpenFeign也是运行在消费者端的，使用Ribbon进行负载均衡，所以OpenFeign直接内置了Ribbon。

测试实例：
	// 使用 @FeignClient 注解来指定提供者的名字
	@FeignClient(value = "eureka-client-provider")
	public interface TestClient {
	    // 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了
	    @RequestMapping(value = "/provider/xxx",
	    method = RequestMethod.POST)
	    CommonResponse<List<Plan>> getPlans(@RequestBody planGetRequest request);
	}

	@RestController
	public class TestController {
	    // 这里就相当于原来自动注入的 Service
	    @Autowired
	    private TestClient testClient;
	    // controller 调用 service 层代码
	    @RequestMapping(value = "/test", method = RequestMethod.POST)
	    public CommonResponse<List<Plan>> get(@RequestBody planGetRequest request) {
	        return testClient.getPlans(request);
	    }
	}




************************zuul************************
统一前缀：
	直接调用服务消费者地址http://localhost:9000/consumer1/student/update；
	这时我们在zuul项目的配置文件中添加zuul.prefix=/zuul
	就需要通过http://localhost:9000/zuul/consumer1/student/update
路由策略配置：
	之前的访问方式会将微服务名称暴露给用户，会存在安全性问题，所以需要自定义路径来代替微服务名称，即自定义路由策略。
	zuul:
		routes:
			consumer1: /FrancisQ1/**
			consumer2: /FrancisQ2/**
	这时就可调用localhost:9000/zuul/FrancisQ1/student/update进行访问了。
服务名屏蔽：
	由于配置完路由策略之后，直接使用微服务名还是能访问的，这时候需要将服务名屏蔽掉。
	zuul:
		ignore-services: "*"
路径屏蔽：
	Zuul还可以指定屏蔽掉的路径URI，即只要用户请求中包含指定的URI路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。
	zuul:
		ignore-patterns: **/auto/**

敏感请求头屏蔽：
	默认情况下，像Cookie、Set-Cookie等敏感请求头信息会被zuul屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。

zuul过滤器：
	过滤器类型：Pre、Routing、Post。前置Pre就是在请求之前进行过滤，Routing路由过滤器就是我们上面所讲的路由策略，而Post后置过滤器就是在 Response 之前进行过滤的过滤器。

令牌桶限流：
	首先我们会有个桶，如果里面没有满那么就会以一定固定的速率会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么这个请求就拒绝，如果获取到那么就放行。

	实例：将请求数量控制在一秒两个。
	@Component
	@Slf4j
	public class RouteFilter extends ZuulFilter {
	    // 定义一个令牌桶，每秒产生2个令牌，即每秒最多处理2个请求
	    private static final RateLimiter RATE_LIMITER = RateLimiter.create(2);
	    @Override
	    public String filterType() {
	        return FilterConstants.PRE_TYPE;
	    }

	    @Override
	    public int filterOrder() {
	        return -5;
	    }

	    @Override
	    public Object run() throws ZuulException {
	        log.info("放行");
	        return null;
	    }

	    @Override
	    public boolean shouldFilter() {
	        RequestContext context = RequestContext.getCurrentContext();
	        if(!RATE_LIMITER.tryAcquire()) {
	            log.warn("访问量超载");
	            // 指定当前请求未通过过滤
	            context.setSendZuulResponse(false);
	            // 向客户端返回响应码429，请求数量过多
	            context.setResponseStatusCode(429);
	            return false;
	        }
	        return true;
	    }
	}



************************网关************************
	详情：https://zhuanlan.zhihu.com/p/101341556

什么是网关？
	服务网关 = 路由转发 + 过滤器
	路由转发：网关接收一切外界请求，转发到后端的微服务上
	过滤器：在服务网关中可以完成一系列横切功能，例如权限校验、限流及监控等。
为什么微服务一定要网关？

微服务架构流程：
	总体流程：服务网关、open-service和service
	1、服务网关、open-service和service启动时都注册到注册中心上去；
	2、用户请求时直接请求网关，网关做智能路由转发到open-service，这包括服务发现、负载均衡、权限校验、监控、限流等操作；
	3、open-service聚合内部service响应，返回给网关，网关再返回给用户。

引入网关的注意点：
	1、增加了网关，就多了层转发（原本用户请求直接访问open-service即可），性能会下降一点（但下降不大，通过网关性能会很好，而且网关与open-service的访问通常是内网访问，速度很快）；
	2、网关的单点问题：在整个网络调用过程中，一定会有一个单点，可能是网关、nginx、dns服务器等。防止网关单点，可以在网关层前边再挂一台nginx，nginx的性能极高，基本不会挂。但是这样一个请求就转发了两次，所以最好的方式是网关单点服务部署在一台牛逼的机器上（通过压测来估算机器的配置），而且nginx与zuul的性能比较，根据国外的一个哥们儿做的实验来看，其实相差不大，zuul是netflix开源的一个用来做网关的开源框架；
	3、网关要尽量轻。

服务网关基本功能：
	1、智能路由：接收外界一切请求，并转发到后端的对外服务open-service上去；
		附：我们只转发外部请求，服务之间的请求不走网关，这就表示全链路追踪、内部服务API监控、内部服务之间调用的容错、智能路由不能在网关完成；当然，也可以将所有的服务调用都走网关，那么几乎所有的功能都可以集成到网关中，但是这样的话，网关的压力会很大，不堪重负。
	2、权限校验：只校验向open-service服务的请求，不校验服务内部的请求；
	3、api监控：只监控经过网关的请求，以及网关本身的一些性能指标（如gc等）
	4、限流：与监控配合
	5、api日志统一收集


技术选型：
	开发语言：java + groovy，groovy的好处是网关服务不需要重启就可以动态的添加filter来实现一些功能；
	微服务基础框架：springboot；
	网关基础组件：netflix zuul；
	服务注册中心：consul；
	权限校验：jwt；
	API监控：prometheus + grafana；
	API统一日志收集：logback + ELK；
	压力测试：Jmeter；








