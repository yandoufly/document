
NIO是什么？适用于何种场景？
	读数据、处理数据、写数据



IO模型：
	IO的各种流是阻塞的，这意味着当一个线程调用read或write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能做其他事情。
	所有IO都分为两个阶段：等待就绪和操作。例如：读函数分为等待系统可读和真正的读；写函数分为等待网卡可写和真正的写。
	等待就绪的阻塞是不使用CPU的，是在“空等”；真正的读写操作的阻塞是使用CPU的，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，基本不耗时。
	以socket.read()为例子：
		BIO，若tcp recvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。
		NIO，若TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。
		AIO，不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。


BIO、NIO、AIO区别？
1.BIO：
	描述：同步并阻塞的IO模型，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务端就会启动一个线程进行处理。
	缺点：若连接不做任何事情会造成不必要的线程开销，可使用线程池机制改善。
	BIO方式适用于连接数目比较小且固定的架构。
2.NIO：
	描述：同步非阻塞的IO模型，服务器实现模式为一个请求一个线程，即客户端发送的连接都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。
	nio也是IO多路复用的基础，是解决高并发与大量连接、IO处理问题的有效方式。
	NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道。
	NIO适用于连接数多且连接比较短（轻架构）的架构。比如聊天服务器，并发局限于应用中。
3.AIO：
	描述：异步非阻塞的IO模型，服务器实现模式为一个有效请求一个线程，即客户端的IO请求都是由OS先完成了，再通知服务器应用区启动线程去处理。
	AIO适用于连接数多且连接比较长（重架构）的架构。比如相册服务器，充分调用OS参与并发操作。
	IO属于底层操作，需要OS支持，并发也需要OS支持，所以性能方面不同操作系统差异也会不同。NIO的非阻塞，需要一直轮询，也是一个比较耗资源的，所以才出现的AIO。


Socket编程：
	socket是操作系统提供的网络编程接口，它封装了对于tcp/ip协议栈的支持，用于进程间的通信。
	Java提供net包用于socket编程，同时支持想Inetaddress、URL等工具类，ServerSocket用于服务端接收tcp请求，Socket用于客户端的请求处理和发送。
1、BIO实现Socket通信(有两处阻塞)：
public class QQServer {
	static byte[] bytes = new byte[1024];
	public static void main(String[] args) {
		ServerSocket serverSocket = null;
		try {
			serverSocket = new ServerSocket();
			serverSocket.bind(new InetSocketAddress(8080));

			while (true) {
				// 阻塞 等待连接
				Socket socket = serverSocket.accept();
				// 阻塞 read读了多少字节 等待用户输入
				int read = socket.getInputStream().read(bytes);
				String content = new String(bytes);
				System.out.println(content);
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				serverSocket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
2、NIO实现Socket通信(处理BIO的两处阻塞)：
public class QQServerNio {
	static byte[] bytes = new byte[1024];
	static List<SocketChannel> list = new ArrayList<>();
	static ByteBuffer byteBuffer = ByteBuffer.allocate(512);
	public static void main(String[] args) throws InterruptedException {
		try {
			// listener
			ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
			serverSocketChannel.bind(new InetSocketAddress(8080));

			while (true) {
				// 阻塞
				SocketChannel socketChannel = serverSocketChannel.accept();
				if (socketChannel == null) {
					Thread.sleep(1000);
					System.out.println("no connect...");
					
					for (SocketChannel client : list) {
						int k = client.read(byteBuffer);
						if (k > 0) {
							byteBuffer.flip();
							System.out.println(byteBuffer.toString());
						}
					}
				} else {
					socketChannel.configureBlocking(false);
					list.add(socketChannel);
					for (SocketChannel client : list) {
						int k = client.read(byteBuffer);
						if (k > 0) {
							byteBuffer.flip();
							System.out.println(byteBuffer.toString());
						}
					}
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}




客户端、服务端的线程模型：
	客户端一般使用单线程模型，当有数据到来时启动线程读取，需要写入数据时开启线程进行数据写入。
	服务端一般使用多线程模型，一个线程负责接收tcp连接请求，每当接收到请求后开启一个线程处理它的读写事件。
	udp的客户端和服务端比较简单，由于udp数据包长度是确定的，只需要写入一个固定的缓存和读取一个固定的缓存空间即可。一般使用DatagramPacket包装一个udp数据包，使用DatagramSocket发送。

IO模型：
	阻塞IO、非阻塞IO、IP多路复用
	详情：https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/network-programming/Java%E7%BD%91%E7%BB%9C%E4%B8%8ENIO%E6%80%BB%E7%BB%93.md

select、poll、epoll作用：
	select、poll、epoll都是IO多路复用中的模型，一般用户程序基于这个去开发自己的IO复用模型。如NIO的非阻塞模型，就是采用了IO多路复用的方式，是基于epoll实现的。
	1、select方式主要使用数组来存储socket描述符，系统将发生事件的描述符做标记，然后IO复用器轮询描述符数组时，就可以知道哪些请求是就绪的。缺点是数组的长度只能到1024，并且需要不断地在内核空间和用户空间之间拷贝数组。
	2、poll方式不采用数组存储描述符，而是使用独立的数据结构来描述，并且使用id来表示描述符，能支持更多的请求数量。缺点和select方式有点类似，就是轮询的效率很低，并且需要拷贝数据。
	1和2两种方法适合在请求总数比较少，并且活跃请求数较多的情况。
	3、epoll函数会在内核空间开辟一个特殊的数据结构，红黑树，树节点中存放的是一个socket描述符以及用户程序感兴趣的事件类型。同时epoll还会维护一个链表，用于存储已经就绪的socket描述符节点。



NIO的核心实现：
	NIO核心由三部分组成：通道(Channel)、缓冲区(Buffer)、选择器(Selector)
1、缓存Buffer：
	有三个变量：
		capacity --buffer的大小/容量
		position --当前读/写的位置
			写操作到缓冲区时，position表示当前待写入的位置，position最大为capacity-1；
			从缓冲区读数据时，position表示从当前位置读取。
		limit	--信息末尾的位置
			写操作，表示能够从buffer里写多少数据。
2、通道Channel

3、Selector
	一个组件，可以检测多个NIO Channel，看看读或写事件是否就绪。
	多个Channel以事件的方式注册到同一个Selector，从而达到一个线程处理多个请求。
	一个thread对应多个channel,一个channel处理一个请求。
	当你调用Selector的select()或者selectNow()方法它只会返回有数据读取的SelectableChannel的实例。






