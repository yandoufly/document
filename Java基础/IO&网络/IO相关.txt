
NIO是什么？适用于何种场景？

IO模型：
	分类：阻塞IO、非阻塞IO、IP多路复用
	详情：https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/network-programming/Java%E7%BD%91%E7%BB%9C%E4%B8%8ENIO%E6%80%BB%E7%BB%93.md

相关概念：
	阻塞、非阻塞（等待数据全部读取成功再返回，还是读取为空马上返回然后下次再读）
	同步、异步（用户缓存主动去读取内核缓存，还是内核缓存读取磁盘成功后通知用户缓存）
	NIO是同步非阻塞模型，也是IO多路复用基础。
	Reactor模式基于同步IO，Proactor模式基于异步IO

IO模型：
	IO的各种流是阻塞的，这意味着当一个线程调用read或write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能做其他事情。
	所有IO都分为两个阶段：等待就绪和操作。例如：读函数分为等待系统可读和真正的读；写函数分为等待网卡可写和真正的写。
	等待就绪的阻塞是不使用CPU的，是在“空等”；真正的读写操作的阻塞是使用CPU的，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，基本不耗时。
	以socket.read()为例子：
		BIO，若TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。
		NIO，若TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。
		AIO，不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。

4种IO模型：
	同步阻塞IO(Blocking IO)：即传统的IO模型
	同步非阻塞IO(Non-blocking IO)：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为Non-block。
	IO多路复用(IO Nultiplexing)：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的selector和Linux中的epoll都是这种模型
	异步IO(Asynchronous IO)：即经典的Proactor设计模式，也称为异步非阻塞IO。


NIO总结：
	代码参考：NioDemo.java类
	nio是面向块（缓冲区）编程，io是面向流编程。
	面向缓冲区编程：数据读写必须经过缓冲区
nio的一些核心包和接口、类：
	java.nio 主要包含了各种与Buffer相关的类
	java.nio.channel 主要包含了与Channel和Selector相关的类和接口
	java.nio.charset 主要包含了与编码相关的类接口
	java.nio.channels.spi 主要包含了与Channel相关的服务提供者编程接口
	java.nio.charset.spi 主要包含了与charset相关的服务提供者编程接口
NIO核心由三部分组成：缓冲区(Buffer)、通道(Channel)、选择器(Selector)
Buffer(缓存)：
	Buffer是一个抽象类，针对缓冲区封装的一个类，提供相应的方法来操作这个缓冲区。
	子类：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer
	核心类：ByteBuffer和CharBuffer。
	ByteBuffer有一个子类 MappedByteBuffer-》能够将文件直接映射到内存中，那么这样我们就可以像访问内存一样访问文件，非常方便

	获取ByteBuffer：
		static ByteBuffer allocate(int capacity); //分配一个新的字节缓冲区
		static ByteBuffer allocateDirect(int capacity); //分配一个新的直接字节缓冲区
		二者区别：
			1、创建普通Buffer成本低，读写的效率不高
			2、创建直接Buffer成本高，所以我们一般用在Buffer生存周期较长的时候使用
			3、只有ByteBuffer才能够创建直接Buffer，其他的Buffer对象是不能够创建
			4、如果创建了直接Buffer但是我又想要使用其他Buffer的功能，可以将ByteBuffer转换成其他Buffer。asIntBuffer()

	4个重要变量：
		关系：0 < mark < postion < limit < capacity
		capacity：buffer的大小/容量。不可以为负数，一旦创建就不能改变
		mark：标记索引，该索引能够用于下次读取或者写入，它只能够在0-position之间
		position：当前读/写的位置
			写操作到缓冲区时，position表示当前待写入的位置，position最大为capacity-1；
			从缓冲区读数据时，position表示从当前位置读取。
		limit：信息末尾的位置。limit后面的数据既不可读，也不可写
			写操作，表示能够从buffer里写多少数据。
	相关方法：
		flip():将写模式切换为读模式， 将limit的值改为postion的值，同时将postion归0。特点: 就是为下一次数据的读取做好准备
		clear(): 将读模式切换为写模式，将limit改为capacity的值，同时将postion归0。特点: 就是为下一次数据的写入做好准备
		put(): 相对读取，向Buffer中存储数据
		get(): 相对读取，从Buffer中获取数据
		mark(): 设置标记位
		reset(): 重置
		hasRemaining(): 判断当前位置和limit之间是否还有元素可处理
		绝对读取: get(index) 不会影响position的位置
		相对读取: put() get() 会影响，每次读取一次，指针后移
2、通道Channel
	3个常用方法：
		read():将Channel中的数据读取到Buffer中
		write():向Buffer中写入数据
		map(mode, position, size):将channel中的数据全部或者部分映射到Buffer中。
			如MappedByteBuffer mappBuffer = inChannel.map(MapMode.READ_ONLY, 0, srcFile.length());
3、Selector
	一个组件，可以检测多个NIO Channel，看看读或写事件是否就绪。
	多个Channel以事件的方式注册到同一个Selector，从而达到一个线程处理多个请求。
	一个thread对应多个channel,一个channel处理一个请求。
	当你调用Selector的select()或者selectNow()方法它只会返回有数据读取的SelectableChannel的实例。


问：直接缓冲区与非直接缓冲器有什么区别？
	...



IO多路复用：
	IO多路复用的场景是我们需要设计一个高性能的网络服务器。该网络服务器能同时跟多个客户端连接，并且能处理这些客户端传上来的请求。
	文件描述符，简称fd
	如何设计一个IO多路复用的网络服务器？
		设计1：我们可以写一个多线程的程序，每个传上来的请求都是一个线程。但是多线程会存在上下文切换。
		设计2：如何用单线程来处理大量客户端连接请求？引出select/poll/epoll

select、poll、epoll作用：
	select、poll、epoll都是IO多路复用中的模型，一般用户程序基于这个去开发自己的IO复用模型。如NIO的非阻塞模型，就是采用了IO多路复用的方式，是基于epoll实现的。
	1、select通过数据来存储。通过轮询数组，才能感知哪个socket来了数据。缺点是数组长度只能是1024，且需要不断在内核空间和用户空间之间拷贝数组。
	2、poll基于链表存储。它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态。本质上跟select没有区别，轮询链表，且需要拷贝数据，但它没有最大连接数的限制。
	1和2两种方法适合在请求总数比较少，并且活跃请求数较多的情况。1和2都需要在内核空间和用户空间之间不断拷贝数据。
	3、epoll基于红黑树存储。它在内核空间开辟该数据结构，树节点中存放的是一个socket描述符以及用户程序感兴趣的事件类型。同时epoll还会维护一个链表，用于存储已经就绪的socket描述符节点。


select模型：
	NIO最主要的就是实现了对异步操作的支持。其中一种通过把一个套接字通道(SocketChannel)注册到一个选择器(Selector)中，不时调用选择器的select方法就能返回满足的选择键(SelectionKey)，键中包含了SOCKET事件信息，这就是select模型。


select和epoll区别？
	1）select有最大并发数限制，默认最大文件句柄数1024，可修改。epoll没有最大文件句柄数限制，仅受系统中进程能打开的最大文件句柄数限制。
	2）select每次都要线性扫描fd_set集合。epoll只在集合不为空才轮询。
	3）select存在内核空间和用户空间的内存拷贝问题。epoll中减少内存拷贝，mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址。

问：Epoll导致的selector空轮询？
	Java NIO Epoll 会导致 Selector 空轮询，最终导致 CPU 100%。
	官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该BUG发生概率降低了一些而已，它并没有得到根本性解决。
	Netty的解决方案：
		对 Selector 的 select 操作周期进行统计，每完成一次空的 select 操作进行一次计数，若在某个周期内连续发生 N 次空轮询，则判断触发了 Epoll 死循环 Bug。
		然后，Netty 重建 Selector 来解决。判断是否是其他线程发起的重建请求，若不是则将原 SocketChannel 从旧的 Selector 上取消注册，然后重新注册到新的 Selector 上，最后将原来的 Selector 关闭。








*****************************************************
Reactor设计模式
概念：
	反应器设计模式(Reactor pattern)是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的事件设计模式。
	当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求，然后派发这些请求至相关的工作线程进行处理。 
	对于Reactor模式，可以将其看做由两部分组成，一部分是由Boss组成，另一部分是由worker组成。Boss就像老板一样，主要是拉活儿、谈项目，一旦Boss接到活儿了，就下发给下面的work去处理。
Reactor模式主要包含下面几部分内容：
	1、初始事件分发器(Initialization Dispatcher)：用于管理Event Handler，定义注册、移除EventHandler等。它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法
	2、同步（多路）事件分离器(Synchronous Event Demultiplexer)：无限循环等待新事件的到来，一旦发现有新的事件到来，就会通知初始事件分发器去调取特定的事件处理器。
	3、系统处理程序(Handles)：操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到Synchronous Event Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。
	4、事件处理器(Event Handler)： 定义事件处理方法，以供Initialization Dispatcher回调使用。
优点
	1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；
	2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；
	3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；
	4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；
缺点
	1）相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。
	2）Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。
	3） Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。




*****************************************************
Socket编程：
	socket是操作系统提供的网络编程接口，它封装了对于tcp/ip协议栈的支持，用于进程间的通信。
	Java提供net包用于socket编程，同时支持想InetAddress、URL等工具类，ServerSocket用于服务端接收tcp请求，Socket用于客户端的请求处理和发送。

TCP/UDP客户端、服务端的线程模型：
	TCP的客户端和服务端的线程模型：客户端一般使用单线程模型，当有数据到来时启动线程读取，需要写入数据时开启线程进行数据写入。服务端一般使用多线程模型，一个线程负责接收tcp连接请求，每当接收到请求后开启一个线程处理它的读写事件。
	
	UDP的客户端和服务端的线程模型：UDP的客户端和服务端比较简单，由于UDP数据包长度是确定的，只需要写入一个固定的缓存和读取一个固定的缓存空间即可。一般使用DatagramPacket包装一个udp数据包，使用DatagramSocket发送。

1、BIO实现Socket通信(有两处阻塞)：
public class QQServer {
	static byte[] bytes = new byte[1024];
	public static void main(String[] args) {
		ServerSocket serverSocket = null;
		try {
			serverSocket = new ServerSocket();
			serverSocket.bind(new InetSocketAddress(8080));

			while (true) {
				// 阻塞 等待连接
				Socket socket = serverSocket.accept();
				// 阻塞 read读了多少字节 等待用户输入
				int read = socket.getInputStream().read(bytes);
				String content = new String(bytes);
				System.out.println(content);
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				serverSocket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
2、NIO实现Socket通信(处理BIO的两处阻塞)：
public class QQServerNio {
	static byte[] bytes = new byte[1024];
	static List<SocketChannel> list = new ArrayList<>();
	static ByteBuffer byteBuffer = ByteBuffer.allocate(512);
	public static void main(String[] args) throws InterruptedException {
		try {
			// listener
			ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
			serverSocketChannel.bind(new InetSocketAddress(8080));

			while (true) {
				// 阻塞
				SocketChannel socketChannel = serverSocketChannel.accept();
				if (socketChannel == null) {
					Thread.sleep(1000);
					System.out.println("no connect...");
					
					for (SocketChannel client : list) {
						int k = client.read(byteBuffer);
						if (k > 0) {
							byteBuffer.flip();
							System.out.println(byteBuffer.toString());
						}
					}
				} else {
					socketChannel.configureBlocking(false);
					list.add(socketChannel);
					for (SocketChannel client : list) {
						int k = client.read(byteBuffer);
						if (k > 0) {
							byteBuffer.flip();
							System.out.println(byteBuffer.toString());
						}
					}
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}


大文件读写操作
	//以空间换取时间。将文件部分或全部映射到内存后进行读写，速度将提高很多。
	MappedByteBuffer buffer = new RandomAccessFile(filePath); 
	内存映射文件首先将外存上的文件映射到内存中的一块连续区域，被当成一个字节数组进行处理，读写操作直接对内存进行操作，而后再将内存区域重新映射到外存文件，这就节省了中间频繁的对外存进行读写的时间，大大降低了读写时间。




