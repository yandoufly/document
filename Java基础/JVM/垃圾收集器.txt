相关链接：
	https://www.cnblogs.com/vana/p/10843289.html

GC类型：
	--详情《GC收集器配置.png》
	-XX:+UseSerialGC
	-XX:+UseParallelGC
	-XX:+UseParallelOldGC
	-XX:-UseParNewGC
	-XX:+UseConcMarkSweepGC
	-XX:+UseG1GC

JDK默认垃圾收集器：
	jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
	jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
	jdk1.9 默认垃圾收集器G1
	-XX:+PrintCommandLineFlagsjvm参数可查看默认设置收集器类型
	-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断

GC日志查看：
	参数列表：
		-XX:+PrintGC 输出GC日志
		-XX:+PrintGCDetails 输出GC的详细日志
		-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
		-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
		-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
		-Xloggc:../logs/gc.log 日志文件的输出路径
	在eclipse.ini中配置下面代码后启动，会在同目录下生成gc.log文件：
		-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs
		新生代GC日志格式：...
		老年代GC日志格式：...
		分析GC日志工具：...

并行(Parallel)与并发(Concurrent)：
	并行：指多条垃圾收集线程并行工作，但此时用户线程处于等待状态；
	并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集线程运行于另一个CPU上。
新生代GC(Minor GC)和老年代GC(Major GC/Full GC)
	新生代GC：发生在新生代的GC。由于Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快
	老年代GC：发生在老年代的GC。出现MajorGC一般会有至少一次MinorGC，MajorGC速度比MinorGC慢10倍以上。
吞吐量：
	吞吐量就是CPU用于运行用户代码时间与CPU总消耗时间的比值。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
	吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)



CMS收集器(Concurrent Mark Sweep)：
	CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。可以使用-XX:+UseConcMarkSweepGC=指定使用，后边接等号指定并发线程数。
执行步骤：
1、初始标记(CMS initial mark):
	初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
2、并发标记(CMS concurrent mark):
	并发标记阶段就是进行GC Roots Tracing的过程。
3、重新标记(CMS remark):
	重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要“Stop The World”。
4、并发清除(CMS concurrent sweep):
	由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

缺点：
	1、CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次FullGC的产生。
	由于CMS并发清理阶段用户线程还在运行着，伴随着用户线程运行自然会有新的垃圾产生，这部分垃圾只能等下一次GC时在清理掉，称为“浮动垃圾”。
	由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。
	2、CMS收集器会产生大量空间碎片。
	CMS收集器基于“标记清除”算法实现，在收集结束后会有大量内存碎片产生。碎片过多时，将会给大对象分配带来麻烦，当大对象找不到足够大连续内存空间分配时，不得不提前触发一次FullGC。






G1收集器：
特性：
1、分代收集
2、空间整合
3、可预测停顿
	建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
4、收集范围缩小
	在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，G1收集器将整个Java堆划分为多个大小相等的独立区域Region。
	G1收集器还保留新生代和老年代的概念，但它们不再是物理隔离，而是一部分region的集合。
	G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Regionl里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以获取尽可能高的手机效率。


执行过程：
1、初始标记(Initial Marking):
	初始标记仅仅只是标记一下GCRoot能直接关联到的对象，并且修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。
	这个阶段会停顿用户线程STW，耗时很短。
2、并发标记(Concurrent Marking):
	并发标记阶段是从GCRoot开始，对堆中对象进行可达性分析，找出存活的对象。
	这个阶段不会停顿用户线程，耗时较长。
3、最终标记(Final Marking):
	最终标记阶段是为了修正2阶段产生的变动，虚拟机将这段时间对象变化记录在线程RememberedSetLogs里面，最终标记阶段需要把RememberedSetLogs的数据合并到RememberedSet中。
	这个阶段会停顿用户线程STW，但是可并行执行。
4、筛选回收(Live Data Counting and Evacuation):
	筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。
