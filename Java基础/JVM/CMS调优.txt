
CMS详细：
	https://www.toutiao.com/i6874925171191316995
	https://blog.csdn.net/zqz_zqz/article/details/70568819

CMS优化过程：
在初始化标记阶段，为了最大限度地减少STW的时间开销，我们可以使用
	-XX:+CMSParallelInitialMarkEnabled
开启初始标记过程中的并行化，进一步提升初始化标记效率；

在重新标记阶段，因为重新标记的内存范围是整个堆，包含_young_gen和_old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作“GC ROOTS”。如果我们分析gc日志发现ReMark阶段发生STW的时间过长，我们就可以开启：
	-XX:+CMSScavengeBeforeRemark

它的作用是在重新标记之前对年轻代做一次minor GC，这样yong gen中剩余待标记的对象数量相比gc之前势必下降很多(只剩下存活的obj，大量死亡的obj被GC干掉了)，剩余被视作“GC ROOTS”的对象数量骤减，如此Remark的工作量就少很多，重新标记的时间开销也会减少；当然这里Remark减少的时间和YGC的时间开销要做一个权衡，根据实践结果选择是否要开启CMSScavengeBeforeRemark；同样在Remark中我们也可以根据实际情况选择是否开启并行化Flag：
	-XX:+CMSParallelRemarkEnabled

总之，性能调优是个理论+实践的技术活，需要我们根据实际情况选择合适的VM参数。

CMS优化总结：
# 优化1：CMS GC是否在fullGC时做压缩（CMS为标记清除算法，不压缩会产生内存碎片）
-XX:+UseCMSCompactAtFullCollection	--默认为true，即做压缩处理
-XX:CMSFullGCsBeforeCompaction=0	--执行多少次fullGC后才做压缩，默认为0。这个参数用来减低fullGC的压缩频率，以减少fullGC暂停时间
# 优化2：降低CMS GC频率或者增加频率、减少GC时长
-XX:CMSInitiatingOccupancyFraction=70 --设定CMS在对内存占用率达到80%时开始GC（因为CMS有浮动垃圾，所以一般都较早启动GC）
-XX:+UseCMSInitiatingOccupancyOnly	--只是用设定的回收阈值（上面指定的70%），如果不指定，JVM仅在第一次使用设定值，后续则自动调整.
# 优化3：在CMS GC前启动一次ygc，以减少GCRoot的对象
-XX:+CMSScavengeBeforeRemark