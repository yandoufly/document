
Lambda表达式：
	格式： (params) -> expression 或 (params) -> { statements; }
	特征：
		可选类型声明
		可选参数圆括号（一个参数可不写）
		可选大括号 && 可选返回关键字


Lambda表达式条件：
	-1）使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法
	-2）使用Lambda必须具有上下文推断。
	备注：有且仅有一个抽象方法的接口，称为“函数式接口”。

语法: parameter -> expression body
主要组成：参数列表 + 箭头 + 表达式体。如(int x, int y) -> x+y;
表达式特征：
	[可选]类型声明：参数类型可不用，编译器自动识别其类型
	[可选]括号：单个参数时，不需要用括号包围参数，多个参数或无参时需要括号
	[可选]花括号：表达式主体仅有一条语句时不需要花括号，若多条语句时需要花括号
	[可选]return关键字：表达式主体是单一表达式，return关键字可不用，编译器自动返回该值。若写了return则需要加上花括号


方法引用：
	若Lambda体中的功能已存在方法提供实现，则可以使用方法引用
	类型：
		类名::静态方法名
		对象::实例方法名
	例如：
		String[] stringArray = { "Barbara", "James", "Mary", "John", "Patricia", "Robert", "Michael", "Linda" };
		Arrays.sort(stringArray, String::compareToIgnoreCase);
		System.out.println(Arrays.asList(stringArray));

--例1：测试Lambda表达式特征
public class LambdaTest {
	
	public static void main(String[] args) {
		// 有无参数类型
		MathOperation addition = (int a, int b) -> a + b;
		MathOperation subtraction = (a, b) -> a - b;
		
		// 有花括号，有return关键字
		MathOperation multiplication = (a, b) -> {return a * b;};
		// 无花括号，无return关键字
		MathOperation division = (a, b) -> a / b;
		
		System.out.println(operate(10, 5, addition));
		System.out.println(operate(10, 5, subtraction));
		System.out.println(operate(10, 5, multiplication));
		System.out.println(operate(10, 5, division));
		
		// 无括号，单个参数情况
		Greet greet = message -> System.out.println("saying::" + message);
		greet.sayMessage("hello");
		greet.sayMessage("hello2");
	}

	private static int operate(int i, int j, MathOperation mathOperation) {
		return mathOperation.operation(i, j);
	}

	interface MathOperation {
		int operation(int a, int b);
	}
	interface Greet {
		void sayMessage(String message);
	}
}



--例2：测试Lambda与方法引用
public class LambdaTest2 {
	
	public static void main(String[] args) {
		User[] userArray = {
				new User("testAA1", Date.valueOf("2018-05-01")),
				new User("testAA3", Date.valueOf("2018-05-03")),
				new User("testAA2", Date.valueOf("2018-05-02")),
				new User("testAA4", Date.valueOf("2018-05-05")),
				new User("testAA5", Date.valueOf("2018-05-05"))};
		// Arrays.sort(userArray, (a, b) -> a.getBirthday().compareTo(b.getBirthday())); //方式一
		// Arrays.sort(userArray, (a, b) -> User.compareByBirthday(a, b)); //方式二
		Arrays.sort(userArray, User::compareByBirthday); //方式三：静态方法引用
		System.out.println(Arrays.asList(userArray));
	}
}
class User {
	private String name;
	private Date birthday;
	
	public User(String name, Date birthday) {
		this.name = name;
		this.birthday = birthday;
	}
	
	public static int compareByBirthday(User a, User b) {
		return a.getBirthday().compareTo(b.getBirthday());
	}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Date getBirthday() {
		return birthday;
	}
	public void setBirthday(Date birthday) {
		this.birthday = birthday;
	}
	
	@Override
	public String toString() {
		return "User [name=" + name + ", birthday=" + birthday + "]";
	}
}








