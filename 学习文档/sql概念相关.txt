*****************************************************************************************

超键、候选键、主键、外键区别：

数据抽象：物理抽象、概念抽象、视图级抽象,内模式、模式、外模式 ？？？？？

事务管理:
	是一系列的数据库操作作为一个逻辑工作单元，是数据库应用的一个基本逻辑单元。
	一个逻辑单元包括四个属性(ACID)：原子性、一致性、隔离性和持久性。
	-1)原子性：即不可切割。对于其数据修改，要么全部执行，要么全部不执行。
	-2)一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态。
	-3)隔离性：由并发事务所作的修改必须与任何其它并发事务所做的修改隔离。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务。
	-4)持久性：事务正确提交后，其结果将永久保存在数据库中。
事务在并发过程中存在的问题：
	-1)脏读：指在一个事务处理过程中读取了另一个未提交事务的数据。 操作流程：改(T1 改两条数据)->读(T2 在改完第一条数据后读取)
	-2)不可重复读：指在数据库查询中，一个事务范围内多次查询却返回了不同的数据值。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 操作流程：读(T1)->改(T2 提交)->读(T1 前后结果不一样) 即多次查询结果不一致
	-3)虚读（幻读）：事务非独立执行时发生的一种现象。 操作流程：改(T1)->插(T2 与修改前的数据一致)->读(T1 觉得数据还未修改一样)


数据库中的连接池：
	服务器启动时会建立一定数量的连接，并一直维持这些池连接客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其标记为忙。


数据库表拆分:
	当数据库表中数据非常大，DB已经成为系统瓶颈时，可以考虑将表进行拆分。
	分类：水平拆分、垂直拆分
	--1）水平拆分：
		一般水平拆分是根据表中的某一字段（通常是主键ID）进行取模，将一张表的数据拆分到多个表中。这样每张表的表结构相同但数据不同。
		除ID取模分表外，还可以通过时间分表（如每月生成一张表），还可以按照范围分表（如一张表最多存储100w数据，超出部分就进行分表）。
		ID取模分表后，我们的查询、修改、删除也是取模。如新增时先生成ID，再根据ID取模得到该存放到哪张表。
	--2）垂直拆分：
		当一张表的字段过多时可以考虑垂直拆分。通常是将一张表的字段拆分为主表及扩展表，使用频率高的字段放在主表，其余的字段放在扩展表。

数据完整性：
1.实体完整性：规定表的每一行在表中是唯一的实体(id不一样)
2.参照完整性：指两个表的主键和外键的数据应一致(从表的外键值全部都应来自于主表的id)
3.域完整性：表中的列满足某种特定的数据类型约束(主要体现在check语句、default语句上)
4.用户定义完整性：针对某种特定的关系数据库的约束条件

维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？
	我是这样做的，尽可能使用约束，如check,主键，外键，非空字段等来约束，这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整新和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。
	疑问：有时候需要从其他公司的数据库推送过来的数据，而这部分数据的某些字段允许为空，但我们的数据库的这些字段不为空？


三个范式：
1）第一范式(1NF)：有主键，每个属性不可再分，同一列中不能又多种值
	若某一列有多种值，可以将该列单独拆分成一个实体，原实体与新实体间是一对多的关系。
2）第二范式(2NF)：满足1NF，数据表的每条记录必须是唯一的（主键约束），且非主键列完全依赖主键列。
	依赖性：如在一张学生信息表（id为主键），不应该出现course_name(课程名称，依赖于course_id)这样的字段。因为需要改课程表时，还得回来修改学生信息表的课程名称

	例如：学生表Student(学号，姓名，性别，课程，课程学分)，存在关系：(课程)->(课程学分)
	若存在非主属性依赖于其它非主属性，则将该组属性单独新建一实体，并且旧实体与新实体间是一对多的关系。
3）第三范式(3NF)：满足2NF，非主键列不可传递依赖主键。
	数据表中不应该存在多余的字段，即每个字段都不能由其它字段推理得到。
	例如：学生信息表里不能同时存在province_id(省份ID)、city_id(城市ID)这两个字段，因为province_id可以由city_id推理得到。
	例如：学生表Student(学号，姓名，性别，系id，系名称)，存在关系：(学号)->(姓名，性别，系id，系名称)，但存在决定关系：(学号)->(所在学院)->(系名称)，因此存在非关键字段“系名称”对关键字段“学号”存在传递函数依赖，因此不是3NF
	它也会存在数据冗余、更新异常、插入异常等问题。

字段冗余：
1.概念
	如在订单表存在订单信息，商品id，商品名称等字段，这里的商品名称是冗余的。
2.考虑
	--1）性能方面：
	以时间换空间，对一些字段做冗余到关联表中，以避免大表之间的join。
	弊端：更新时需要同步更新多张表。如更改username字段时，需要更新所有username字段的表。
	--2）业务方面：
	快照场景。交易场景大部分是数据快照。
	用户下单时间时的用户名、地址、商品名称、商品描述等，若采用关联，商品在下单后发生了更新时再去做关联查询就会导致和用户操作时的数据不一致，从而产生纠纷。
	比如，order表有id、goodsId，goods表有id、price。用户今天下单，价格位100.过几天卖家涨价了，价格涨为200.用户申请退款，系统给他退款200，这显然不合理，所以这里的price需要冗余，order表中的price表示“下订单时的商品价格”。


*****************************************************************************************
精通Oracle
	详情：https://www.jianshu.com/nb/4871765 --未整理（重要）

表空间：
	表空间里ORACLE中的一个逻辑概念，它用于存放数据库文件，而数据库文件是存放在磁盘的数据文件，是物理概念。
	一个房间可以存储很多箱子，箱子里面可以存储物品！表空间可以看成房间，箱子可以看成数据文件，物品可以看成表。用户指定表空间也就是希望把属于这个用户的表放在那个房间（表空间）里面。

创建表空间、用户、表、授权过程：
	connect system/0529;
	--创建表空间
	--格式：create tablespace 表空间名 datafile '数据文件名' size 表空间大小;
	create tablespace oe_tablespace datafile 'E:\stu\oe.dbf' size 200M;
	--创建用户
	--格式：create user 用户名 identified by 密码 [default tablespace 表空间名];
	create user testuser identified by 1230 default tablespace oe_tablespace;
	--将表空间分配给用户
	alter user testuser default tablespace oe_tablespace;
	--授权给新建用户
	grant create session,create table,unlimited oe_tablespace to testuser;
	grant connect,resource,dba to testuser; --把connect、resource权限授予testuser用户
	--用户登录，登录之后创建表即可
	conn testuser/1230;


plsql语法：
declare
	变量1 	变量类型1;
	变量2 	变量类型2;
begin
	代码块...

	EXCEPTION
		when 异常名1 then 处理异常1...
		when 异常名2 then 处理异常2...
end;

异常：
	myEx exception; --声明
	raise myEx; --抛出
	when myEx then 处理自定义异常...
	when others then 处理其它异常...
	--例如：
	when others then
		ROLLBACK; --回退
		p_bg_log('P_PHYSICAL_EXAMINATION_FETCH', ...); --存日志


变量：
1.分4大类：
	-1）number。如（i number(2) := 100;）
	-2）varchar2。如（msg varchar2(12) := '结果是：';）
	-3）与列名类型相同。如（pname emp.ename%type;）
	-4）与整个表的列类型相同。如（emp_record emp%rowtype;）
2.测试：
	--输出7369号员工姓名和工资(表名.字段%type)
	declare
		pname	emp.ename%type;
		psal	emp.sal%type;
	begin
		select ename into pname, sal into psal from emp where emp_id = 7369;
		dbms_output.put_line('7369号员工的姓名是' || pename || ',薪水是' || psal);
	end;
	--输出7788号员工姓名和工资(表名%rowtype)
	declare
		emp_record	emp%rowtype;
	begin
		select * into emp_record from emp where empno = 7788;
		dbms_output.put_line('7788号员工的姓名是' || emp_record.ename || ',薪水是' || emp_record.sal);
	end;

判断体(if)：
1.语法：
	if 条件1 then SQL语句...
	elsif 条件2 then	 SQL语句...
	else SQL语句...
	end if;

while循环体：
for循环体：


Oracle 游标(cursor)：
	--可使用“变量名 表名%ROWTYPE”替换
	是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
	语法：cursor 游标名[(参数名 数据类型, ...)] is select语句;
	分类：隐式游标(DML操作)、显式游标
	使用：
		--1.声明游标：参数可选，如果定义了参数，则必须在打开游标时传递相应的实际参数。
		cursor cursorName[(param1 type, param2 type...)] is select_clause;
		--2.打开游标：打开游标时，select语句的查询结果就被传送到游标工作区
		open cursorName into 变量1[,变量2...];
		--3.提取游标
		fetch cursorName into 变量名1[, 变量2...];
		--4.关闭游标
		close cursorName;


Oracle 视图(view)：
	是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
	语法：create view viewName as (select...)


Oracle 触发器(trigger)：
	触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。
	当满足触发器条件，则系统自动执行触发器的触发体。
	触发时间：有before,after.
	触发事件：有insert,update,delete三种。	
	分类：DML触发器、DDL触发器和登陆触发器
	--语法：
	create [or replace] trigger 触发器名 before/after insert/update/delete
		on tableName [for each row]
	begin
		sql语句...
	end;


Oracle 函数(function)：
基本语法：
	create [or replace] function functionName [(paramlist)] //函数名称，参数可省略
		return dataType //返回类型
	{is | as}
		[local_declarations] //局部变量声明.例如：id char2(32); empName varchar2(30);
	begin
		executable_statements; //可执行语句
		raise 异常名; //抛出异常
	[exception
		when 异常名 then ...] //异常捕获
	end functionName;
使用：
	--测试1：得到年份
	create or replace function FUN_GET_EXPLAN_YEAR(emp_type in varchar2)
		return number 
	is
		explanYear number;
	begin
		select to_number(t.c1) into explanYear from biz_bm_dbase t where t.type = emp_type;
		return explanYear;
	end FUN_GET_EXPLAN_YEAR;

	--测试2：通过函数查询数据返回游标（函数不能直接返回数据集合）
	--详情：https://blog.csdn.net/nohero1/article/details/44174701
	create or replace function test111(itemNumber in varchar2)
		return SYS_REFCURSOR
	is
		return_cursor SYS_REFCURSOR; 
	begin
		OPEN return_cursor FOR SELECT 'a' FROM dual WHERE '1' = itemNumber; 
		RETURN return_cursor;
	end test111;
	--测试（点击后能看到对应数据）：
		select test111(1) from dual;


Oracle 存储过程(procedure)：
1.基本语法：
	create [or replace] procedure procedureName [(paramlist)] //存储过程名称，参数可省略。paramlist格式：param1 in type, param2 out type
	{is | as}
		[local_declarations] //局部变量声明.例如：id char2(32); empName varchar2(30);
	begin
		executable_statements; //可执行语句
		raise exceptionName; //抛出异常
	[exception
		when exceptionName then ...] //异常捕获
	end procedureName;
2.使用：
	exec p_rep_echarts_050801('44', '201908'); --执行存储过程
	drop procedure procedureName;	--删除存储过程

3.基本概念：
	存储过程就是编译好了的一些sql语句。
	存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。

4.优点：
	-1）SQL语句已经预编绎过了，因此运行的速度比较快。
	-2）可保证数据的安全性和完整性。可设定只有某此用户才具有对指定存储过程的使用权，保证数据的安全性。通过存储过程可以使相关的动作在一起发生，从而可以维护数据库的完整性。
	-3）存储过程运行在服务器上，减少对客户机的压力。
	-4）可以接受参数、输出参数、返回单个或多个结果集以及返回值。可以向程序返回错误原因
	-5）可以包含程序流、逻辑以及对数据库的查询。同时可以实体封装和隐藏了数据逻辑。
5.测试：
	--实例1
	create or replace procedure P_RER(p_date_scope in varchar2, p_data in char)
	is
		v_begin_date varchar2(6) := substr(p_date_scope, 1, 6);
		v_sysdate    date := sysdate;
		v_insert_sql varchar(500) := 'insert into tableName (data, begin_date, v_sysdate) t values (:1, :2, :3)';
	begin
		execute immediate v_survey_sql using p_data, v_begin_date, v_sysdate;
		commit;
	end P_RER;

	--实例2：uuid
	create or replace procedure test_procedure
	is
		c_row	 biz_project_temp%rowtype;
		v_guid    VARCHAR2(100);
	begin
		FOR c_row IN (select rowid from biz_project_temp) LOOP
			select sys_guid() into v_guid from dual;
			insert into ...
		END LOOP;
	end test_procedure;


参数列表中的in、out、in out说明：
	附：in，out，in out是形参的模式。
	in --默认，在程序运行中已有值，不能被修改。只能将实参传递给形参，进入函数内部，但只能读不能写，函数返回时实参的值不改变；
	out --只能在过程内部赋值，表示该参数可以将某个值传递回调。形参初始值总是null，但函数内部可以被读写，函数返回时形参的值赋给实参；可用于存储过程调用存储过程，传入参数会跟着改变的场景。
	in out --高参数可以向该过程中传递值，也可以将某个值传出去。调用时实参的值总是传递给形参，结束时，形参的值传递给实参。

	演示in效果：
	--例如：根据id查找该雇员姓名(默认编号为79)
	create or replace procedure findEmp(empId in number)
	as
		empName varchar2(30);
	begin
		select ename into empName from emp where id = empId;
		dbms_output.put_line('雇员姓名是'||empName);
	exception
		when no_data_found then
			dbms_output.put_line('该编号雇员未找到');
	end findEmp;
	调用：excute findEmp(79);

	演示out效果：
	--例如：存储过程调用另一存储过程，参数值会跟着改变
	create or replace procedure test(empId varchar2, str2 out number);
	is 
		identity number;
	begin
		select sal into identity from emp where empno = empId;
		if identity < 2000 then
			str2 := 1000;
		else
			str2 := 500;
		end if;
	end test;
	调用：
	declare
		str2 number;
	begin
		test('79', str2);
		dbms_output.put_line(str2);
	end;

	演示in out效果：
	--例如：两个数据交换
	create or replace procedure swap(p1 in out number, p2 in out number)
	is
		p_temp number;
	begin
		p_temp := p1;
		p1 := p2;
		p2 := p_temp;
	end;
	调用：
	declare
		num1 number := 100;
		num2 number := 200;
	begin
		swap(num1, num2);
		dbms_output.put_line('num1='||num1);
		dbms_output.put_line('num2='||num2);
	end;



*****************************************************************************************
详情：
	https://www.jianshu.com/p/0124c0cb052c	//数据库SQL性能优化（一）


SQL优化：
	具体链接：http://blog.csdn.net/u011463470/article/details/51016928
	执行顺序：select--from--where--group by--having--order by
	1.在经常需要进行检索的字段上创建索引
		比如要按照姓名进行检索，则应该在姓名字段上创建索引。
		创建索引给检索带来的性能是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。
	2.使用预编译查询
		动态执行SQL，尽量使用参数化SQL，不仅防止漏洞攻击，数据库还会对这些参数化SQL进行预编译，这样再次执行该SQL时直接使用预编译的结果。
	3.执行顺序
		from子句：从右到左，即写在最右边的表最先被处理。一般尽量把数据量小的表放在最右边。多对多表的选择交叉表放最右边
		where子句：从右到左，但条件的顺序对SQL性能没有影响。一般把能使结果最少的条件放在最右边。
	4.使用表的别名
	5.用exists替代in，用not exists替代not in，因为not in对子查询中的表执行一个全表遍历
	如：把a表中存在但在b表中不存在的数据插入的b表中
		insert into b select * from a where not exists (select * from b where id=a.id)
	6.用union all替换union
	7.避免在索引列上使用(is null 或 is not null)，不能用null做索引，任何包含null值的列都将不会被包含在索引中。 

Oracle SQL优化：
优化概述：
	-1）首先建立适当索引。索引字段不可加函数，保证索引起效。复合索引需要注意sql顺序，不要跨列。
	-2）最大数据量的表放在最前，最小的表放在最后面。sql是从最后面开始反向解析的。
	-3）其次是要把最有效缩小范围的条件放到sql末尾去。尤其是主键或者索引字段的条件。

优化方向：

	查询字段：
		1、查询字段可能来自表本身，也可能来自其它表。当字段来自其它表，且不作为查询条件时，可以直接在select子句查询，以减少对表的连接，若查询该字段频繁可考虑做成冗余字段。
		2、查询字段可能是多个字段合并而成，也可能是其它表多条记录排序后合并。
	查询条件：
		1、查询条件很大程度上取决于索引。
		2、若传入的条件不走索引时我们应该换一种思路去实现，如证件号码后六位匹配，使用like右匹配不走索引，但可以创建substr函数的索引，从而达到快速查询到结果。
from子句的表顺序：
	Oracle解析器按照从右到左的顺序解析。FROM子句中写在最后的表将被最先处理。
	建议：记录条数最少的表放在最后！！！
	描述：当ORACLE处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表（FROM子句中最后的那个表）并对记录进行排序，然后扫描第二个表（FROM子句中倒数第二张表），最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并。
	--例如：表tab1有16,384条记录，表tab2有1条记录
	select count(*) from tab1,tab2; --tab2放最后（高效），执行时间0.96秒
	select count(*) from tab2,tab1; --tab1放最后（低效），执行时间26.09秒
where子句的连接顺序：
	Oracle采用自下而上的顺序解析。
	建议：表连接条件写在where句首；可以过滤最大数量记录的条件写在where末尾！！
	--例如：
	select * from emp e where sal>5000 and job='manager' and 25<(select count(*) from emp where mgr=e.empno);--低效，执行时间156.3秒
	select * from emp e where 25<(select count(*) from emp where mgr=e.empno) and sal>5000 and job='manager';--高效，执行时间10.6秒


PL/SQL按F5查询sql执行顺序。

识别“低效执行”的SQL语句
SELECT EXECUTIONS, --所有子游标的执行这条语句次数
       DISK_READS, --所有子游标运行这条语句导致的读磁盘次数
       BUFFER_GETS, --所有子游标运行这条语句导致的读内存次数
       ROUND((BUFFER_GETS - DISK_READS) / BUFFER_GETS, 2) HIT_RADIO, --命中率
       ROUND(DISK_READS / EXECUTIONS, 2) READS_PER_RUN, --每次执行读写磁盘数
       SQL_TEXT	--执行的SQL语句
  FROM V$SQLAREA
 WHERE EXECUTIONS > 0
   AND BUFFER_GETS > 0
   AND (BUFFER_GETS - DISK_READS) / BUFFER_GETS < 0.8
 ORDER BY 4 DESC;


实战：
--生成千万条数据
create table t_user as
select rownum as id,
	(sysdate + rownum/24/3600) as create_time,
	trunc(dbms_random.value(0, 100)) as age,
 	dbms_random.string('x', 20) username
from dual
	connect by level <= 10; --生成10条数据
	--connect by level <= 10000000;


--优化原则：
1.优先索引字段(索引使用参见底下)

2.减少对表的查询
	--查询
	select * from t1 where a = (select a from t2 where version = 604) and b = (select b from t2 where version  = 604); --低效
	select * from t1 where (a, b) = (select a, b from t2 where version = 604); --高效
	--update多个列
	update t1 set a = (select max(a) from t2), b = (select max(b) from t2) where t1.name = '002'; --低效
	update t1 set (a, b) = (select max(a), max(b) from t2) where t1.name = '002'; --高效

3.用exists代替in
	select * from emp where dept_id in (select id from dept where name = 'A'); --低效
	select * from emp a where exists (select 1 from dept b where b.id = a.dept_id and name = 'A'); --高效

4.用not exists代替not in
	在子查询中，not in子句将执行一个内部的排序和合并。无论哪种情况下，not in都是最低效的（因为它对子查询中的表执行全表遍历）。
	可以使用外连接(outer join)或not exists代替。
	--例如：
	select * from emp where dept_id not in (select id from dept where dept_cat='A') --低效
	select * from emp a, dept b where a.dept_id = b.id(+) and b.id is null and b.dept_cat(+) = 'A'; --高效(表关联，直接两表关联的速度是最快的！)
	select * from emp a where not exists (select 1 from dept b where b.id = a.dept_id and dept_cat = 'A') --高效(not exists)



尽量多使用commit
	在程序中尽量多使用commit，这样程序的性能得到提高，需求也会因为commit所释放的资源而减少。
	commit所释放的资源：
		a)回滚段上用于恢复数据的信息
		b)被程序语句获得的锁
		c)redo log buffer中的空间
		d)Oracle为管理上述3种资源中的内部花费


*****************************************************************************************
索引(index):
概念：
	数据库中查找操作非常普遍，索引就是提升查找速度的一种手段。索引可以是唯一的，允许指定单个列或者是多个列。
	缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。
	创建索引：create (unique) index indexName on tableName(colName);
分类：
	B+树索引、哈希索引、全文索引、RTree索引
	唯一索引：在创建外键约束和唯一约束时会自动创建
	普通索引：create index idx_age on t_user(age);
约束：
	alter table t_user add constraint pk_user primary key (id); --主键约束(会自动创建唯一索引)
	alter table t_user add constraint uq_user_name unique (name); --唯一约束(会自动创建唯一索引)
	alter table t_user add constraint fk_user_role_id foreign key (role_id) references t_role (id);	--外键约束
	alter table t_user add constraint check_age check (age > 18 and age < 55); --check约束1
	alter table t_user add constraint check_age check (age between 1 and 100); --check约束2

优点：
	-1）创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
	-2）可以大大加快数据的检索速度；
	-3）加速了表与表之间的连接，特别是实现数据参照完整性有特别意义；
	-4）在使用分组和排序子句进行数据检索时，显著减少查询中分组和排序的时间；
	-5）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
缺点：
	-1）创建和维护需要耗费时间，随着数据量的增加而增加；
	-2）对表的数据进行增、删、改操作时，索引也需要动态维护；
	-3）当修改性能远远大于检索性能时，不应创建索引。

不走索引的地方：
	-1）在索引列上使用函数不会使用索引。（如：to_char(hire_date,'yyyymm')='201809'条件不使用索引）
	-2）等号两边类型不同。（如：'a'=1时不走索引，1=1时走索引）
	-3）索引字段is null
	-4）like后面的字符首位为通配符时不走索引
	-5）使用<>不走索引，当<>会返回少量的结果时使用(< or >)来替代
什么时候使用索引：
	-1）经常出现用作查询选择的字段
	-2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
	-3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
	-4）经常出现在group by,order by和distinc关键字后面的字段
	-5）经常出现在Where子句中的字段
哪些情况不加索引：
	-1）很少出现在查询选择的字段
	-2）那些只有很少数据值的列也不应该增加索引。比如性别，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大
	-3）数据类型为text、image和bit的列不应该增加索引
	-4）当修改性能远远大于检索性能时，不应该创建索引。

索引使用原则：
	-1）避免where条件的null值判断，否则将导致引擎放弃索引而进行全表扫描。
		索引字段不可设值为null，非索引字段可使用null值。
		设置非空：alter table t_user modify username not null;
		若char(100)型，在字段创建时空间就固定了，不管是null值，都是100个字符；若是varchar等可变长字段，null不占空间。
		--测试：
		create index idx_age on t_user(age);
		select * from t_user where age is null;	--不走索引
	-2）避免!= 或 <> 操作符，否则将导致引擎放弃索引而进行全表扫描。

	-3）避免使用 or 连接。
		若一个字段有索引，一个字段无索引，将导致引擎放弃索引而进行全表扫描。
		or的两侧若有一侧没索引时，引擎会放弃索引而产生全表扫描。
		可使用union all代替or
	-4）避免使用select*
		--测试：2千万条数据，username未添加索引
		select * from t_user where username = 'PQVQX8L4VF18AJD0ZOWH'; --耗时4.672s
		select id,birthday,age,username from t_user where username = 'PQVQX8L4VF18AJD0ZOWH'; --耗时耗时2.469
	-5）避免like使用右匹配
		select * from t_user where username like '%test'; --不走索引
		select * from t_user where username like 'test%'; --走索引
	-6）避免索引字段上添加函数、算术运算、或表达式运算
		select id from t where substring(name,1,3) = 'abc'; --未使用索引
		select id from t where name like 'abc%';	--使用索引
	-7）复合索引命中问题
		参照最左匹配原则，注意写条件顺序，不要跨列使用。
	-8）其它
		一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
		尽可能使用varchar代替char，尽可能使用数字型代替字符型。


联合索引：
	详情：https://blog.csdn.net/Abysscarry/article/details/80792876

	对多个字段同时建立索引，有顺序，ABC和ACB是完全不同的两种联合索引。建立联合索引abc，则相当于建立了a、ab、abc三个索引。一个索引顶三个索引当然是好事，毕竟每多一个索引都会增加写操作的开销和磁盘空间的开销。
	最左匹配原则：abc三列，mysql会首先匹配a，然后再b、c。若使用bc来检索时会找不到a使得索引失效。若使用ac索引，会先找到所有a的值然后匹配c，此时联合索引是失效的。
	联合索引类似电话簿，人名由姓和名构成，电话簿首先按姓氏排序，再对相同姓氏的人排序。若仅知道姓，电话簿将非常有用；若知道姓和名，电话簿则更有用；若仅知道名，电话簿将没用处。

	--实例：有1000w条数据的表，使用select * from table where a=1 and b=2 and c=3。假设每个条件可以筛选出10%的数据。
		-1）若为单值索引，通过索引能筛选出1000w*10%=100w条数据，然后在回表从100w条数据中找到符合b=2 and c=3的数据，最后再排序、分页等操作；
		-2）若为符合索引，通过索引筛选出1000w*10%*10%*10%=1w，最后再排序、分页等操作。

	创建联合索引abc：
		--相当于创建了单列索引a、联合索引ab、联合索引abc-1）查询条件a，联合索引有效
		-2）查询条件b，联合索引无效。查询条件c，联合索引无效。
		-3）查询条件ab，联合索引有效。查询条件ba，联合索引有效。
		-4）查询条件ac，联合索引有效，但实际上只用到了a的索引，c并没有用到！
		-5）查询条件bc，联合索引无效。
		-6）查询条件abc，联合索引有效。
		-7）查询条件a or b，联合索引无效。
	注意：
		多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！
		单值索引需要注意的事项，组合索引全部通用。如索引列不参与计算、or的两侧要么都索引或都不是索引、模糊匹配时%不要在头部等。
		建索引有一定开销，若数据量少则没必要创建索引（速度反而慢）。
		or的两侧要么都索引，要么都不索引。若两侧有一侧没索引，引擎会放弃索引而产生全表扫描
		联合索引比对每个列分别索引更有优势，因为建立索引越多越占磁盘空间，再更新数据时速度会更慢。
		建立联合索引时需按顺序添加查询条件，这样效率更高。（感觉这句话不需要，mysql执行优化器会对其进行优化）
	问题：
		问1：同时存在联合索引和单列索引，这时mysql会怎么用索引？
			这个涉及到mysql本身的查询优化器策略，当一个表有多条索引可走时，mysql根据查询语句的成本来选择走哪条索引。
		问2：最左前缀原则，以最左边的为起点任何连续的索引都能匹配上？
			abc联合索引，a放在最左边。

	index_merge作用:
		索引合并是把几个索引的范围扫描合并成一个索引；
		索引合并时，会对索引进行并集、交集或先交集再并集操作，以便合并成一个索引。
		这些需要合并的索引只能是一个表的。不能对多表进行索引合并。
		应用场景：
			-1）如“c1='xx' or c2='xx'”的or操作，c1和c2列分别有索引，可以按照c1和c2条件查询，再将查询结果并集(union)操作，得到最终结果
			-2）如“c1='xx' and c2='xx'”的and操作，c1和c2列分别有索引，可以按照c1和c2条件查询，再将查询结果交集(intersect)操作，得到最终结果


*****************************************************************************************
分析函数(over)：
	详情：https://blog.csdn.net/Alen_Liu_SZ/article/details/90552174?utm_source=app
	Oracle从8.1.6开始提供分析函数，分析函数用于计算基于组的某种聚集值，对于每个组返回多行，而聚集函数对于每个组只返回一行。
组成部分：
	3个基本组成部分：分区子句、排序子句、开窗子句
	语法：fun(arg1, arg2, ...) over([partition-by-clause] [order-by-clause] [windowing-clause])
	--例如：查询每个人的薪资、及部门薪资总和、部门累计薪资
	select empno, sal, sum(sal) over(partition by deptno) as 部门薪资总和, sum(sal) over(partition by deptno order by sal asc) as 部门累计薪资 from t_temp;
测试：
	create table t_score(stuId varchar2(20), stuName varchar2(50), classId number, score float);
	insert into t_score values ('111', 'testAA1', 1, 92);
	insert into t_score values ('112', 'testAA2', 1, 90);
	insert into t_score values ('113', 'testAA3', 1, 100);
	insert into t_score values ('114', 'testAA4', 2, 92);
	insert into t_score values ('115', 'testAA5', 2, 90);
	insert into t_score values ('116', 'testAA6', 2, 92);
	--测试1：查询每个人的成绩、所有班级平均分、及所属班级平均分
	select t.*, round(avg(score) over(), 2) avg_score, round(avg(score) over(partition by t.classid), 2) class_avg_score from t_score t;
	--测试2：查询每个人成绩、及所属班级总成绩、平均成绩、最高成绩、最低成绩
	select t.*, --每个人信息
		sum(score) over(partition by t.classid) class_sum_score, --所属班级总分
		avg(score) over(partition by t.classid) class_avg_score, --所属班级平均分
		min(score) over(partition by t.classid) class_min_score, --所属班级最低分
		max(score) over(partition by t.classid) class_max_score  --所属班级最高分
	from t_score t;

row_number、rank和dense_rank使用：
1.区别：
	--都是用于排序，row_number只返回一条数据，不适合有两条相同成绩的记录。
	-1）row_number有两个并列第一，row_number()只返回一个结果。只返回一条数据，不适合有两条相同成绩的记录。
	-2）rank会跳跃排序，有两个第二名时接下来就是第四名。若两条相同成绩的记录则并列排名。测试中的testAA4和testAA6成绩相同，并排第1名，而testAA5排第3名，第2名无人
	-3）dense_rank是连续排序，有两个第二名时仍然跟着第三名。是rank的补充，因为rank排序时无第2名，dense_rank排名时testAA5是第2名。
2.测试：班级里按成绩排名(三种写法区别)
	select t.*,
		row_number() over(partition by classId order by score desc) rn,
		rank() over(partition by classId order by score desc) r,
		dense_rank() over(partition by classId order by score desc) dr
	from t_score t;


first_value与last_value使用：
	用于返回一个排序结果集中的第一个值。
	--测试：返回每个人的成绩及所属班级的最高成绩（last_value不会用）
	select t.*, first_value(score) over(partition by classid order by score desc) f_score from t_score t;
	select t.*, last_value(score) over(partition by classid order by score range between unbounded preceding and unbounded following) l_score from t_score t;


listagg使用：
	将多行结果合并成一行，用于分组内对数据排序后再对值拼接。
	语法：listagg(列表达式, 分隔符) with group(order_by_clause) [over(partition_by_clause)]
	--测试1：成绩由高到低排名
	select listagg(t.stuname, '、') within group(order by t.score desc) names from t_score t;
	--测试2：查询班级成绩由高到低排名
	select classid, listagg(stuname, '、') within group(order by score desc) as names from t_score group by classid;
	--测试3：查询每个人的成绩、及所属班级排名
	select t.*, listagg(t.stuname, '、') within group(order by t.score desc) over(partition by t.classid) names from t_score t;


wm_concat(str)函数：
	行合并成一行，用“,”分隔。(注：需将colb转成string)
	语法：to_cahr(wm_concat(to_char(colName))) --说明：wm_concat返回clob类型，会出现乱码问题，需转化为string类型
	--测试：按type分组，得到type的所有名称（不可排序！！）
	select type, to_char(wm_concat(to_char(name))) names from test group by type;
	注：与排序(orderBy)连用会出现缺失右括号，建议使用listagg()函数
	
	--测试：将行中每个列拼接在一起，再将所有行拼接成一行后输出
	select ph.person_id, to_char(wm_concat(to_char(ph.visit_date, 'yyyy-mm-dd'))) visit_date_str
		from ph_physical_examination ph group by ph.person_id;
	注：上述语句可能会报错，原因如下
		-1）wm_concat查询出的是LOB类型（包括BLOB和CLOB两种）
		-2）oralce的SQL语句中若查询了LOB字段是不能使用distinct，union，和group by等关键字的

	--改良(使用listagg函数)：
	select ph.person_id,
		listagg(to_char(ph.visit_date, 'yyyy-mm-dd'), '、') within group(order by ph.visit_date) visit_date_str
		from ph_physical_examination ph group by ph.person_id

实例：查询某个对象的最新联系记录
1.常规
select b.* 
	from gp_contact_info b,
		(select a.group_id, max(a.contact_date) max_contact_date from gp_contact_info a group by a.group_id) c
	where b.group_id = c.group_id and b.contact_date = c.max_contact_date;
2.通过分区查询(partition by ...)
select * from (
	select row_number() over(partition by c.group_id order by c.contact_date desc) rowIndex,
		c.GROUP_ID,
		c.NEXT_CONTACT_DATE,
		c.NEXT_TODO,
		c.NEXT_CONTACT_PG_WEEK,
		c.NEXT_CONTACT_AGE,
		c.NEXT_CONTACT_MONTH
	from gp_contact_info c) t where t.rowIndex = 1
合并某一列(关键字listAgg)：
	--实例：根据personId和age分段，从而获取某段存在多少个体检日期
	select a.person_id, a.age,
		ListAgg(to_char(a.visit_date, 'yyyy-mm-dd'), '、') within group(order by a.person_id) as sss
	from ph_children_health_check_two a group by a.person_id, a.age;


*****************************************************************************************