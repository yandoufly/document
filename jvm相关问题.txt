jvm内存分配规则：
	详情：https://blog.csdn.net/hyg0811/article/details/101444643
1.对象优先在eden分配：
2.大对象直接进入老年代：
	大对象指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。
	虚拟机提供一个-XX:PretenureSizeThreshold参数，大于该值的对象直接在老年代分配。其目的是避免在Eden区及两个Survivor区之间发生大量的内存复制
3.长期存活的对象将进入老年代
	虚拟机给每个对象定义了一个对象年龄（Age）计数器。每经过一次Minor GC则对象年龄+1，当年龄达到15岁（默认值），就会晋升到老年代。
	年龄阈值设置：-XX:MaxTenuringThreshold

	问：jvm的分代年龄为什么是15？
		在32位HotSpot虚拟机中，若对象处于未被锁定的状态下，那么Mark Word的32bit空间中25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0。
		因此，对象的分代年龄占4位，也就是0000，最大值为1111也就是最大为15，而不可能为16，20之类的了。
4.动态对象年龄
	虚拟机并不是永远地要求兑现过的年龄必须达到了MaxTenuringThreshold才能晋升老年代。
	对象能晋升老年代条件：
		-1）虚拟机并不是永远地要求兑现过的年龄必须达到了MaxTenuringThreshold才能晋升老年代；
		-2）若Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

方法区卸载Class的条件：
	1）该类所有的实例已经被回收
	2）加载该类的ClassLoader已经被回收
	3）该类对应的java.lang.Class对象没有任何地方被引用
	附：方法区除了回收无用class，也回收废弃常量，即没有被引用常量

类加载：
三个类加载器：
	启动类加载器(BootStrap classloader):负责将Java_HOME/lib下的类库加载到虚拟机内存中，比如rt.jar
	扩展类加载器(Extension classloader):负责将JAVA_HOME/lib/ext下的类库加载到虚拟机内存中
	应用程序类加载器(Application classloader):负责加载classpath环境变量下指定的类库。如果程序中没有自定义过类加载器，那么这个就是程序中默认的类加载器。
双亲委派模型
	概念：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
	目的：防止自定义的一些跟jdk标准库中冲突的全限定名的类被加载，导致标准库函数不可用。