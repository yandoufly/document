
top #查看占用最高的进程
	top -H -p pid #查看进程pid中比较耗资源的线程
	jstack pid | grep 31ff #查看对内存，31ff为线程id=12799的16进制


GC优化过程：
	-1）监控GC状态
	-2）分析监控结果后决定是否需要优化GC
	若分配很大内存后依然出现了OutOfMemoryError，则执行“堆快照（heap dump）”来消除导致异常的原因。？？？
	-3）设置GC类型/内存大小
	-4）分析结果：设置完GC参数后就可以开始收集数据，请在收集至少24小时后再进行结果分析。
	-5）如果结果令人满意，将参数应用到所有服务器上，并结束 GC 优化


jvm OOM和内存泄漏
	oom一般分为三种：堆内存溢出、栈内存溢出和方法区内存移除
	堆内存溢出主要原因是创建了太多对象，比如一个集合类死循环添加一个数，此时设置jvm参数使堆内存最大值为10m，一会就会报oom异常。
	栈内存溢出主要与栈空间和线程有关，因为栈是线程私有的，如果创建太多线程，内存值超过栈空间上限，也会报oom。
	方法区内存溢出主要是由于动态加载类的数量太多，或不断创建一个动态代理，jdk1.7之前会报permGem OOM，jdk1.8则会报meta space oom，因为jdk1.8中使用元数据区替换了堆中的永久代。

	内存泄漏一般是因为对象被引用无法回收，比如一个集合中存着很多对象，可能你在外部代码把对象的引用置空了，但是由于对象还被集合给引用着，所以无法被回收，导致内存泄漏。测试也很简单，就在集合里添加对象，添加完以后把引用置空，循环操作，一会就会出现oom异常，原因是内存泄漏太多了，导致没有空间分配新的对象。


内存溢出和内存泄漏区别？
	内存溢出是创建太多对象导致内存空间不足；内存泄漏是无用对象没有回收
JVM怎么判断无用对象？
	根搜索算法，从GCRoot出发，对象没有引用，就判定为无用对象
根搜索算法中的根节点可以是哪些对象？
	类对象，虚拟机栈的对象，常量引用的对象


常用调试工具：
	命令行工具有jstack jstat jmap 等。
	jstack可以跟踪线程的调用堆栈，以便追踪错误原因。
	jstat可以检查jvm的内存使用情况，gc情况以及线程状态等；
	jmap用于把堆栈快照转储到文件系统，然后可以用其他工具去排查。
	visualvm是一款很不错的gui调试工具，可以远程登录主机以便访问其jvm的状态并进行监控。



jvm监控工具：
jps：jvm进程状况工具
	格式：jps [options] [hostid]
	options说明:
		-q不输出类名、jar名和传入main方法的参数
		-l输出main类或jar的全限名
		-m输出传入方法的参数
		-v输出传入jvm的参数

jstat：jvm统计信息监控工具
	jstat用于监视虚拟机各种运行状态信息的命令工具。它可以显示本地或远程虚拟机进行中的类装载、内存、垃圾收集、jit编译等运行数据，它是线上定位jvm性能的首选工具。
	格式：jstat [generalOption | outputOptions vmid [interval | [s|ms] [count]]]
		generalOption	#单个常用的命令行选项，如-help,-options或-version
		outputOptions	#一个或多个输出选项，由单个statOption选项组成，可以和-t,and -j等选项配合使用
	参数选项：
		jstat -class pid #显示加载class的数量，及所占空间等信息
		jstat -compiler pid #显示vm实时编译的数量等信息
		jstat -gc pid #显示gc信息，查看gc的次数及时间。其中最后五项分别为young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。
		更多详情：https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA9%EF%BC%9AJVM%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%AF%8A%E6%96%AD%E5%AE%9E%E8%B7%B5.md

jinfo：java配置信息
	格式：jinfo [option] pid

jmap：Java内存映射工具
	用于生产堆转存快照。打印出某个Java进行（使用pid）内存内的，所有对象的情况。（如产生那些对象，及其数量）
	格式：
		jmap [option] pid
		jmap [option] executable core

jmap命令(Java Memory Map)：
	jmap用于生成heap dump文件。
	如果不使用这个命令，还可以利用-XX:+HeapDumpOutOfMemoryError参数来让虚拟机出现OOM错误时自动生成dump文件。
	jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。
	堆快照（heap dump）：
		堆快照是一个用来检查Java内存中的对象和数据的内存文件。该文件可以通过执行JDK中的jmap命令来创建。在创建文件的过程中，所有Java程序都将暂停，因此，不要在系统执行过程中创建该文件。？？？



jstack：Java堆栈跟踪工具
	用于生成Java虚拟机当前时刻的线程快照。线程快照是当前Java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等等。



****************************应用****************************
cpu飙升
	描述：在线上有时候某个时刻，可能会出现应用某个时刻突然cpu飙升的问题。对此我们应该熟悉一些指令，快速排查对应代码。。
	1.找到最耗cpu的进程：top
	2.找到该进程最耗cpu的线程：top -Hp pid
	2.转换进制：printf "%x\n" 15332 #转换16进制（转换后为0x3be4）
	3.过滤指定线程，打印堆栈信息
		--打印进程堆栈，并通过线程id，过滤得到线程堆栈信息
		语法：jstack pid | grep 'threadPid' -C5 --color
		例如：jstack 15325 | grep '0x3be4' -C5 --color



jvm调优-jstack找出最耗cpu的线程并定位代码
	> ps -ef | grep projectName 	#1.先找出项目对应进程ID(pid)
	> top H -p pid 	#2.找出该进程最消费cpu的线程
	> printf "%x\n" 2012 #得到线程Id为2012其对应的十六进制7dc
	> jstack 32464 | grep 7dc	#一般会进到jdk的bin目录下，root权限执行
	> 第四步：查代码


查看耗cpu的线程：
	top -查看最耗费cpu的进程
	top H -p pid #查看具体的线程信息
	jstack pid | grep -A 10 [线程的16进制]


线程死锁
	描述：比如说我们现在已经有一个线程死锁的程序，导致某些操作waiting中
	1.查找Java进程：top或jps
	2.查看Java进程的线程快照信息：
		--从输出信息可以看到，有一个线程死锁发生，并且指出了那行代码出现的。如此可以快速排查问题
		jstack -l pid

Java死锁排查：
	详情：https://www.cnblogs.com/aflyun/p/9194104.html
	1.运行死锁程序
	2.命令窗口使用jps+jstack
	> jps -l #获取pid，即Java进程ID
	> jstack -l pid #查看线程，能发现死锁
	> JConsole #打开图形化监控工具
	> jvisualvm #打开图形化监控工具

