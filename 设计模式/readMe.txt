

com.yjy.singleton // 单例
	5种实现单例模式方式：饿汉式、双重检查、静态内部类方式、枚举方式

com.yjy.builderTest // 建造者模式
	测试煎饼果子，根据自己的喜好让老板加鸡蛋、加生菜、加里脊、加火腿、加辣椒等。
	步骤：创建建造类 -》 加鸡蛋/生菜等 -》 调用build方法，开始构建


com.yjy.strategy // 策略模式
	v1版本：原始版本计算器
	v2版本：使用策略模式将各算法的实现分解


com.yjy.decoration // 装饰器模式
	v1版本：女孩子化妆
	v2版本：女孩子化妆、涂口红
	v3版本：画三角形、矩形，加不同颜色、不同尺寸等


com.yjy.responsibilityChain // 责任链
	v1版本：无设计模式完成 员工、经理、CEO的审批流程
	v2版本：使用责任链实现

com.yjy.responsibilityChain2 // 责任链
	v1版本：测试责任链进行用户登录的一些列校验
		校验顺序 验证码->用户名密码-》是否重复登录
		缺点：需要手动指定顺序
	v2版本：和建造者模式联用
		在Handler类添加一个Builder静态内部类，用于处理v1版本手动指定顺序的问题。

com.yjy.responsibilityChain3 // 责任链（跟responsibilityChain2一样）
	--流程：
	1、创建需校验实体
	2、创建抽象校验器类AbstractHandler
	3、创建具体校验类，并都继承抽象校验类：账号密码校验类、角色校验类、权限校验类
	4、创建一个建造者类，用于搭配各种不同的校验类及它们的顺序
	5、测试

	--v1版本：
		使用责任链编写用户登录一系列校验
		方式1：责任链模式
		方式2：构造者模式+责任链模式
	--v2版本，改造v1版本，将具体的校验类的doNextHandler(loginUser);去掉，循环调用链在抽象父类实现
		与版本1区别：具体校验不通过，还是会往下执行下一个校验类
		解决：
			1、具体校验类抛出异常，抽象父类接收到异常后跳出循环
			2、具体校验类的方法改成boolean返回，true-校验通过，false-校验不通过
	--v3版本，改造v2版本，通过“解决1”处理v2遗留问题

com.yjy.visitor2 // 访问者模式
	步骤1：先定义抽象产品，并定义两个具体产品ProducerA和ProducerB
	步骤2：定义访问者，通过重载方法实现访问所有的产品
	步骤3：测试（这样只能访问单个产品，同时不能访问多个产品）
	解决：把每个产品变成接待者，即实现Acceptor接口，主动接待所有的访问者Visitor（测试3）




