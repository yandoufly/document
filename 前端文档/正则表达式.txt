正则表达式：
	用来检查一个串是否含有某种字串、将匹配的子串替换等。

特殊字符：
	$	匹配字符串的结尾位置
	()	标记一个子表达式的开始和结束位置。
	?	匹配前面的子表达式出现（0次或1次），等价于{0,1}
	*	匹配前面的子表达式出现（0次或多次），等价于{0,}
	+	匹配前面的子表达式出现（1次或多次），等价于{1,}
	.	匹配除了换行符\n外的一个字符
	[	标记一个中括号表达式的开始
	^	转义
	{	标记限定符表达式的开始
	|	指明两项之间的一个选择

限定符：
	6种分类：?或*或+或{n}或{n,}或{n,m}
	

定位符：
	^	匹配输入字符串开始的位置
	$	匹配输入字符串结尾的位置
	实例：
		/^Chapter [1-9][0-9]{0,1}/		--匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首



“^”和“[^指定字符串]”之间的区别：
	1.“^”是匹配字符串开始的位置
	2.“[^指定字符串]”是匹配除了指定字符串以外的其它字符串
	例如：
	(^[0-9])+	//匹配有一至多个数字的字符串组合
	[^[0-9]]+	// 匹配有一至多个不含数字的字符串组合




\		转义字符
^		匹配输入字符串的开始位置
$		匹配输入字符串的结束位置
?		匹配前面的子表达式出现（0次或1次），等价于{0,1}
*		匹配前面的子表达式出现（0次或多次），等价于{0,}
+		匹配前面的子表达式出现（1次或多次），等价于{1,}
{n}		匹配确定的n次。例如，“o{2}”匹配“food”中的两个o
{n,}	匹配至少n次。例如，“o{2}”匹配“fooood”中的四个o
{n,m}	最少匹配n次且最多匹配m次。例如，“o{1,3}”匹配“fod”中的一个o
?		该字符紧跟任何其它字符（？，*,+,{n},{n,},{n,m}）时，匹配模式是非贪婪的。非贪婪模式匹配尽可能少的字符串，而默认的贪婪模式匹配尽可能多的字符串。例如，对于字符串“0000”，“0+”得到的结果为[“0000”]，而“0+?”得到的结果为['0','0','0','0']
.		匹配除“\r\n”外的单个字符
(pattern)		匹配pattern并获取这一匹配
(?:pattern)		非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。
(?=pattern)		....
(?!pattern)		....
(?<=pattern) 	....
(?<!pattern)	....
x|y		匹配x或y。例如，“[z|f]ood”则匹配“zood”或“food”
[xyz]	匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。
[^xyz]	匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。
[a-z]	匹配“a”到“z”范围内的任意小写字母字符
[^a-z]	匹配任何不在“a”到“z”范围内的任意字符
\b		例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”
\B 		例如，“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”
\d 		匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持
\D 		匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持


正则表达式的贪婪和非贪婪匹配：
	如String str = "abcaxc"; Patter p = "ab*c"; 贪婪匹配为abcaxc，而非贪婪匹配为abc
	贪婪匹配：默认，正则表达式一般趋向于最大长度匹配，也就似乎所有的贪婪匹配。
	非贪婪匹配：就是匹配到结果就好，最少的匹配字符。
	Java中用正则表达式截取字符串中第一个出现的英文左括号之前的字符串。比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式为“.*?(?=\\()”。
		.*?是非贪婪匹配，表示找到最小的就可以了。
		(?=Expression)顺序环视，(?=\\()就是匹配正括号
		java正则表达式中的 ‘\’ 在java字符串中要写为 ‘\\’ 



案例：
	/^.{1,3}$/.test('1222'); //1~3字符串