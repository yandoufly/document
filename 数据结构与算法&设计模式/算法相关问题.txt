

算法题：
	走迷宫
	游戏通关
	走台阶
	断钢筋
	背包问题
排序算法：
	八大排序算法及复杂度介绍？快排、堆排序、归并排序
	哪些排序算法是稳定的，哪些是不稳定的？
	快速排序，过程，复杂度？什么情况下适用，什么情况下不适用？
	归并排序的过程？时间复杂度？空间复杂度？ 
	二分搜索的过程
	
链表：
	反转链表
	判断链表是否有环
	交叉链表的交点
	复杂链表的复制
	二叉树变成双向链表
	什么是二叉平衡树，如何插入节点，删除节点

树：
	前序遍历、中序遍历、后序遍历
	前序(MLR-根左右)
	中序(LMR-左根右)
	后序(LRM-左右根)


做搜索、回溯问题的套路是画图，代码其实就是根据画出的树形图写出来的。
如何画图？
	1、根据题目中的用例，画一个图，因为是搜索，因此呈现的是一个树形结构图，并且在这个树形结构中会体现出递归结构。
	2、根据题目中的用例，比对自己画图的结果和题目的结果的差异，如果一样，说明我们的分析没有错；如果不一样，说明我们的分析有误，一定有哪一个环节漏掉了或者分析错误，根据找到的问题调整算法。


递归算法步骤：
	1、了解递归函数功能
	2、找出递归结束条件
	3、找出函数的等价关系式


算法问题：
	给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少？
	给你一个数组，如何里面找到和为K的两个数？
	100000个数找出最小或最大的10个？topK问题
	一堆数字里面继续去重，要怎么处理？
	八大排序算法？时间复杂度？
	实现一致性hash？


问：最优的集合去重，时间复杂度为O(1)。
	常规做法：本来10W条记录的记录，若新添加一条记录，则都要跟原来10W条记录做对比，起时间复杂度为O(n)。
	优化：类似于HashMap的结构，先创建一个大的数组，直接将集合元素插入数组中，若该数组下标已存在元素，则说明是重复元素



问：最大子序列和（动态规划）
	描述：给定数组nums，找到一个具有最大和的连续子数组，返回其最大和。
	示例：
		输入：[-2,1,-3,4,-1,2,1,-5,4]
		输出：6
		解释：连续子数组[4,-1,2,1]的和最大，为6

	实现思路：
		用数组d[i]来保存当前最大的连续子数组，循环遍历每个数，然后每次检查d[i-1]是否大于0，是则d[i]=d[i-1]+nums[i]；否则d[i]=nums[i]。
	
	算法核心：d[i] = d[i-1] >= 0 ? d[i-1] + nums[i] : nums[i];
	走一遍流程：
		[-2]						//d[0]=-2;初始化，这里仅有一个数，它就是最大连续子数组；
		[-2,1]						//d[1]=nums[0]=1;d[0]<0；前面最大连续是负数，加上它们会变小
		[-2,1,-3] 					//d[2]=d[1]+nums[2]=-2;d[1]=1>=0；前面的最大连续是正数，加上它们会变大
		[-2,1,-3,4] 				//d[3]=nums[3]=4;
		[-2,1,-3,4,-1] 				//d[4]=d[3]+nums[4]=3;
		[-2,1,-3,4,-1,2]			//d[5]=d[4]+nums[5]=5;
		[-2,1,-3,4,-1,2,1]			//d[6]=d[5]+nums[6]=6;
		[-2,1,-3,4,-1,2,1,-5]		//d[7]=d[6]+nums[7]=1;
		[-2,1,-3,4,-1,2,1,-5,4]		//d[8]=d[7]+nums[8]=5;


问：反转链表
	--就地反转：1指向3，2指向1。反复循环直到1.next为null；
	dummy->1->2->3->4->5
	dummy->2->1->3->4->5
	dummy->3->2->1->4->5
	dummy->4>-3->2->1->5
	dummy->5->4->3->2->1


问：数组中查找两数之和为K的序列对
	算法：借助hashMap存储计算过程，对于第i元素，若存在key=nums[i]则直接返回key和value，若不存在则存入HashMap中<sum-nums[i], nums[i]>


问：对于5位的01串，每一位都可能是0或1，一共32种可能。它们前几个是00000、00001、00010...，请按从小到大打印这32种01串。
	规律：每一位都可能是0或1，使用可以使用for循环输出0和1；有5位则使用5个for循环输出
	--代码如下：
	for(int a = 0; a < 2; a++)
			for(int b = 0; b < 2; b++)
				for(int c = 0; c < 2; c++)
					for(int d = 0; d < 2; d++)
						for(int e = 0; e < 2; e++)
							System.out.printf("%d%d%d%d%d\n", a,b,c,d,e);

问：从数组中取出n个元素的所有组合
	规律：若从数组中取出1位，遍历一遍数组即可；若取出2位，遍历2遍数组即可，但第二位数的下标一定小于第一位数下标。

	--代码如下：从数组中任意取出3位数
	int[] num = {1, 2, 3, 4, 5, 6};
	for (int a = 0; a < num.length; a++) {
		for (int b = 0; b < num.length; b++) {
			if (b <= a) continue;
			for (int c = 0; c < num.length; c++) {
				if (c <= b) continue;
				System.out.printf("%d,%d,%d\n", num[a], num[b], num[c]);
			}
		}
	}

问：topK问题
	描述：从arr[1, n]这n个数中，找出最大的k个数。
	方法一：快排，时间复杂度O(n*lg(n))
	方法二：局部排序，循环k次，找出最大的k个数，时间复杂度O(n*k)
	方法三：堆实现。堆先存入k个值并已排序；然后存入第K+1的值，若大于堆内扫描到的元素，则替换并调整堆，以保证堆内的k个元素总是当前最大的k个元素。
	方法三：数组实现。数组中先存入K个值。当存入第k+1的值时，先扫描数组得到最小值与第k+1值比较，若大于的替换，以保证数组内k个元素总是当前最大的k个元素。


问：青蛙跳台阶
	描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。时间复杂度O(n)
	答：登上第一级台阶有一种登法；登上两级台阶，有两种登法；登上三级台阶，有三种登法；登上四级台阶，有五种方法……所以，1，2，3，5，8，13……登上十级，有89种。

	算法：
		每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。
		第一种跳法：跳一个台阶，那么剩下n-1个台阶还没跳，剩下的n-1个台阶有f(n-1)种跳法
		第二种跳法：跳两个台阶，那么剩下n-2个台阶还没跳，剩下的n-2个台阶有f(n-2)种跳法

	public static int JumpFloor(int target) {
		if (target <= 0) return -1;
		else if (target == 1)  return 1;
		else if (target ==2) return 2;
		else return  JumpFloor(target-1)+JumpFloor(target-2);
	}


问：删除已排序数组中的重复项
	描述：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
	例：
		数组nums = [1,1,2]，函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
		给定 nums = [0,0,1,1,1,2,2,3,3,4],返回长度2，并且被修改为0, 1, 2, 3, 4。
	思路：两个指针i和j。j>i。若nums[i] == num[j]则j++，否则将nums[j]替换nums[i+1];且i++;
	--代码实现：
	public class Main {
		public static void main(String[] args) {
			int[] nums = {1, 1, 2};
			int removeDuplicates = removeDuplicates(nums);
			for(int i = 0; i < removeDuplicates; i++) {
				System.out.print(nums[i] + " ");
			}
		}
		
		public static int removeDuplicates(int[] nums) {
			int len = nums.length;
			if (len < 2) return len;
			
			int i = 0, j = 0;
			while (++j < len) {
				if (nums[i] != nums[j]) {
					i++;
					if (i != j) {
						nums[i] = nums[j];
					}
				}
			}
			return i + 1;
		}

		// 别人的算法！！！
		public static int removeDuplicates(int[] nums) {
			int count = 0, len = nums.length;
			for (int i = 1; i < len; i++) {
				if (nums[i-1] == nums[i]) {
					count++;
				} else {
					nums[i - count] = nums[i];
				}
			}
			
			return len - count;
		}
	}



问：移除元素
	描述：给定数组nums和一个值val，原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
	public class Main {
		public static void main(String[] args) {
			Main mm = new Main();
			int[] nums = {0,1,2,2,3,0,4,2};
			int val = 2;
			int removeElement = mm.removeElement(nums, val);
			System.out.println(removeElement);
			for (int i : nums) {
				System.out.print(i + " ");
			}
		}

		// 思路：遍历数组，若存在指定数，则count++，若count=0则说明前面的元素都不等于指定数，若count=1则说明前面有一个元素等于指定数，则需要移动1位
		public int removeElement(int[] nums, int val) {
			int count = 0, len = nums.length;
			for (int i = 0; i < len; i++) {
				if (nums[i] == val) {
					count++;
				} else {
					nums[i - count] = nums[i];
				}
			}
			return len - count;
		}

		//别人的代码
		public int removeElement(int[] nums, int val) {
			int n = 0;
	        for(int i = 0; i < nums.length; i++){
	            if(nums[i] != val){
	                nums[n] = nums[i];
	                n++;
	            }
	        }
	        return n;
		}
	}









