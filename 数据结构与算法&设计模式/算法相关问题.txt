

算法题：
	走迷宫
	游戏通关
	走台阶
	断钢筋
	背包问题
排序算法：
	八大排序算法及复杂度介绍？快排、堆排序、归并排序
	哪些排序算法是稳定的，哪些是不稳定的？
	快速排序，过程，复杂度？什么情况下适用，什么情况下不适用？
	归并排序的过程？时间复杂度？空间复杂度？ 
	二分搜索的过程
	
链表：
	反转链表
	判断链表是否有环
	交叉链表的交点
	复杂链表的复制
	二叉树变成双向链表
	什么是二叉平衡树，如何插入节点，删除节点

树：
	如何遍历一棵二叉树？
	参考：TreeTest.java
	前序遍历、中序遍历、后序遍历
	前序(MLR-根左右)
	中序(LMR-左根右)
	后序(LRM-左右根)



做搜索、回溯问题的套路是画图，代码其实就是根据画出的树形图写出来的。
如何画图？
	1、根据题目中的用例，画一个图，因为是搜索，因此呈现的是一个树形结构图，并且在这个树形结构中会体现出递归结构。
	2、根据题目中的用例，比对自己画图的结果和题目的结果的差异，如果一样，说明我们的分析没有错；如果不一样，说明我们的分析有误，一定有哪一个环节漏掉了或者分析错误，根据找到的问题调整算法。


递归算法步骤：
	1、了解递归函数功能
	2、找出递归结束条件
	3、找出函数的等价关系式


算法问题：
	给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少？
	给你一个数组，如何里面找到和为K的两个数？
	100000个数找出最小或最大的10个？topK问题
	一堆数字里面继续去重，要怎么处理？
	八大排序算法？时间复杂度？
	实现一致性hash？


问：最优的集合去重，时间复杂度为O(1)。
	常规做法：本来10W条记录的记录，若新添加一条记录，则都要跟原来10W条记录做对比，起时间复杂度为O(n)。
	优化：类似于HashMap的结构，先创建一个大的数组，直接将集合元素插入数组中，若该数组下标已存在元素，则说明是重复元素

问：求数组的最长连续递增数列，如：4，200，3，1，100，2。结果是1，2，3，4
	算法1：先排序，然后从前往后遍历，if (array[i]-array[i-1]==1) dp[i]=dp[i-1]-1; else dp[i]=1;
	面试官：用一个hashtable，hash到4的时候，看看hash（3）和hash（5）是否存在，类似这样的思路



问：反转链表
	--就地反转：1指向3，2指向1。反复循环直到1.next为null；
	dummy->1->2->3->4->5
	dummy->2->1->3->4->5
	dummy->3->2->1->4->5
	dummy->4>-3->2->1->5
	dummy->5->4->3->2->1


问：数组中查找两数之和为K的序列对
	算法：借助hashMap存储计算过程，对于第i元素，若存在key=nums[i]则直接返回key和value，若不存在则存入HashMap中<sum-nums[i], nums[i]>


问：对于5位的01串，每一位都可能是0或1，一共32种可能。它们前几个是00000、00001、00010...，请按从小到大打印这32种01串。
	规律：每一位都可能是0或1，使用可以使用for循环输出0和1；有5位则使用5个for循环输出
	--代码如下：
	for(int a = 0; a < 2; a++)
			for(int b = 0; b < 2; b++)
				for(int c = 0; c < 2; c++)
					for(int d = 0; d < 2; d++)
						for(int e = 0; e < 2; e++)
							System.out.printf("%d%d%d%d%d\n", a,b,c,d,e);

问：从数组中取出n个元素的所有组合
	规律：若从数组中取出1位，遍历一遍数组即可；若取出2位，遍历2遍数组即可，但第二位数的下标一定小于第一位数下标。

	--代码如下：从数组中任意取出3位数
	int[] num = {1, 2, 3, 4, 5, 6};
	for (int a = 0; a < num.length; a++) {
		for (int b = 0; b < num.length; b++) {
			if (b <= a) continue;
			for (int c = 0; c < num.length; c++) {
				if (c <= b) continue;
				System.out.printf("%d,%d,%d\n", num[a], num[b], num[c]);
			}
		}
	}

问：topK问题
	描述：从arr[1, n]这n个数中，找出最大的k个数。
	方法一：快排，时间复杂度O(n*lg(n))
	方法二：局部排序，循环k次，找出最大的k个数，时间复杂度O(n*k)
	方法三：堆实现。堆先存入k个值并已排序；然后存入第K+1的值，若大于堆内扫描到的元素，则替换并调整堆，以保证堆内的k个元素总是当前最大的k个元素。
	方法三：数组实现。数组中先存入K个值。当存入第k+1的值时，先扫描数组得到最小值与第k+1值比较，若大于的替换，以保证数组内k个元素总是当前最大的k个元素。
