概念：
	数据库中查找操作非常普遍，索引就是提升查找速度的一种手段。索引可以是唯一的，允许指定单个列或者是多个列。
	缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。

语法：create (unique) index indexName on tableName(colName);

分类：
	B+树索引、哈希索引、全文索引、RTree索引
	唯一索引：在创建外键约束和唯一约束时会自动创建
	普通索引：create index idx_age on t_user(age);
	函数索引：（实例：证件号码后六位查询）

约束：
	alter table t_user add constraint pk_user primary key (id); --主键约束(会自动创建唯一索引)
	alter table t_user add constraint uq_user_name unique (name); --唯一约束(会自动创建唯一索引)
	alter table t_user add constraint fk_user_role_id foreign key (role_id) references t_role (id);	--外键约束
	alter table t_user add constraint check_age check (age > 18 and age < 55); --check约束1
	alter table t_user add constraint check_age check (age between 1 and 100); --check约束2

优点：
	-1）创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
	-2）可以大大加快数据的检索速度；
	-3）加速了表与表之间的连接，特别是实现数据参照完整性有特别意义；
	-4）在使用分组和排序子句进行数据检索时，显著减少查询中分组和排序的时间；
	-5）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
缺点：
	-1）创建和维护需要耗费时间，随着数据量的增加而增加；
	-2）对表的数据进行增、删、改操作时，索引也需要动态维护；
	-3）当修改性能远远大于检索性能时，不应创建索引。

不走索引的地方：
	--附：走不走索引可查看《执行计划》的描述
	-1）在索引列上使用函数不会使用索引。（如：to_char(hire_date,'yyyymm')='201809'条件不使用索引）
	-2）等号两边类型不同。（如：'a'=1时不走索引，1=1时走索引）
	-3）索引字段is null
	-4）like后面的字符首位为通配符时不走索引
	-5）使用<>不走索引，当<>会返回少量的结果时使用(< or >)来替代
什么时候使用索引：
	-1）经常出现用作查询选择的字段
	-2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
	-3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
	-4）经常出现在group by,order by和distinc关键字后面的字段
	-5）经常出现在Where子句中的字段
哪些情况不加索引：
	-1）很少出现在查询选择的字段
	-2）那些只有很少数据值的列也不应该增加索引。比如性别，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大
	-3）数据类型为text、image和bit的列不应该增加索引
	-4）当修改性能远远大于检索性能时，不应该创建索引。

索引使用原则：
	-1）避免where条件的null值判断，否则将导致引擎放弃索引而进行全表扫描。
		索引字段不可设值为null，非索引字段可使用null值。
		设置非空：alter table t_user modify username not null;
		若char(100)型，在字段创建时空间就固定了，不管是null值，都是100个字符；若是varchar等可变长字段，null不占空间。
		--测试：
		create index idx_age on t_user(age);
		select * from t_user where age is null;	--不走索引
	-2）避免!= 或 <> 操作符，否则将导致引擎放弃索引而进行全表扫描。

	-3）避免使用 or 连接。
		若一个字段有索引，一个字段无索引，将导致引擎放弃索引而进行全表扫描。
		or的两侧若有一侧没索引时，引擎会放弃索引而产生全表扫描。
		可使用union all代替or
	-4）避免使用select*
		--测试：2千万条数据，username未添加索引
		select * from t_user where username = 'PQVQX8L4VF18AJD0ZOWH'; --耗时4.672s
		select id,birthday,age,username from t_user where username = 'PQVQX8L4VF18AJD0ZOWH'; --耗时耗时2.469
	-5）避免like使用右匹配
		select * from t_user where username like '%test'; --不走索引
		select * from t_user where username like 'test%'; --走索引
	-6）避免索引字段上添加函数、算术运算、或表达式运算
		select id from t where substring(name,1,3) = 'abc'; --未使用索引
		select id from t where name like 'abc%';	--使用索引
	-7）复合索引命中问题
		参照最左匹配原则，注意写条件顺序，不要跨列使用。
	-8）其它
		一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
		尽可能使用varchar代替char，尽可能使用数字型代替字符型。


**************************************联合索引**************************************
详情：https://blog.csdn.net/Abysscarry/article/details/80792876

概念：
	1、对多个字段同时建立索引，有顺序，ABC和ACB是完全不同的两种联合索引。建立联合索引abc，则相当于建立了a、ab、abc三个索引。一个索引顶三个索引当然是好事，毕竟每多一个索引都会增加写操作的开销和磁盘空间的开销。
	2、最左匹配原则：abc三列，mysql会首先匹配a，然后再b、c。若使用bc来检索时会找不到a使得索引失效。若使用ac索引，会先找到所有a的值然后匹配c，此时联合索引是失效的。
	3、联合索引类似电话簿，人名由姓和名构成，电话簿首先按姓氏排序，再对相同姓氏的人排序。若仅知道姓，电话簿将非常有用；若知道姓和名，电话簿则更有用；若仅知道名，电话簿将没用处。

实例：有1000w条数据的表，使用select * from table where a=1 and b=2 and c=3。假设每个条件可以筛选出10%的数据。
	-1）若为单值索引，通过索引能筛选出1000w*10%=100w条数据，然后在回表从100w条数据中找到符合b=2 and c=3的数据，最后再排序、分页等操作；
	-2）若为符合索引，通过索引筛选出1000w*10%*10%*10%=1w，最后再排序、分页等操作。

创建联合索引abc：
	--相当于创建了单列索引a、联合索引ab、联合索引abc-1）查询条件a，联合索引有效
	-2）查询条件b，联合索引无效。查询条件c，联合索引无效。
	-3）查询条件ab，联合索引有效。查询条件ba，联合索引有效。
	-4）查询条件ac，联合索引有效，但实际上只用到了a的索引，c并没有用到！
	-5）查询条件bc，联合索引无效。
	-6）查询条件abc，联合索引有效。
	-7）查询条件a or b，联合索引无效。
注意：
	多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！
	单值索引需要注意的事项，组合索引全部通用。如索引列不参与计算、or的两侧要么都索引或都不是索引、模糊匹配时%不要在头部等。
	建索引有一定开销，若数据量少则没必要创建索引（速度反而慢）。
	or的两侧要么都索引，要么都不索引。若两侧有一侧没索引，引擎会放弃索引而产生全表扫描
	联合索引比对每个列分别索引更有优势，因为建立索引越多越占磁盘空间，再更新数据时速度会更慢。
	建立联合索引时需按顺序添加查询条件，这样效率更高。（感觉这句话不需要，mysql执行优化器会对其进行优化）
问题：
	问1：同时存在联合索引和单列索引，这时mysql会怎么用索引？
		这个涉及到mysql本身的查询优化器策略，当一个表有多条索引可走时，mysql根据查询语句的成本来选择走哪条索引。
	问2：最左前缀原则，以最左边的为起点任何连续的索引都能匹配上？
		abc联合索引，a放在最左边。

index_merge作用:
	索引合并是把几个索引的范围扫描合并成一个索引；
	索引合并时，会对索引进行并集、交集或先交集再并集操作，以便合并成一个索引。
	这些需要合并的索引只能是一个表的。不能对多表进行索引合并。
	应用场景：
		-1）如“c1='xx' or c2='xx'”的or操作，c1和c2列分别有索引，可以按照c1和c2条件查询，再将查询结果并集(union)操作，得到最终结果
		-2）如“c1='xx' and c2='xx'”的and操作，c1和c2列分别有索引，可以按照c1和c2条件查询，再将查询结果交集(intersect)操作，得到最终结果



问：聚簇索引和非聚簇索引的区别？
	聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据；
	非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。

什么是覆盖索引？
	描述：一个索引包含（或覆盖）所有需要查询的字段的值，即只需扫描索引而无需回表。
	覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B-tree索引做覆盖索引。

MySQL主键索引和普通索引区别？
	MySQL默认的存储引擎InnoDB。
	无论是主键索引还是辅助索引最终都会使用B+树来存储数据，其中前者在表中以<id, row>的方式存储，而后者会以<index, id>的方式进行存储。