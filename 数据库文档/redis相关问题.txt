redis应用场景：
	缓存（热门数据）
	分布式锁
	集群时session共享
	分布式自增ID


非关系型数据库的优势，解决什么问题？
	不用关心各种约束问题。

redis和memcached有什么区别？
	数据类型：redis支持多种数据类型，memcached仅支持简单key/value数据类型。
	数据持久化：redis支持rdb和aof两种。memcached不支持数据持久化
	运行模型：redis使用单线程，而memcached使用多线程。redis使用单核，而memcached可利用多核。在处理小的文件时redis会比memcached有更高的效率，但是在100K以上时，memcached的效率就会更高一些。
	集群：都可以集群，不过在100k以上的数据中，memcached性能要高于redis


Redis单线程为什么能达到10W吞吐量？Redis的高并发和快速原因？
	1、redis基于内存，内存的读写速度非常快；
	2、redis是单线程，省去了很多上下文切换线程的时间；
	3、redis采用多路复用技术，可以处理并发的连接。非阻塞IO内部实现epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在IO上浪费一点时间。


基于内存为什么会快？
	内存与CPU直接交换数据，所以内存越大，运行速度越快。
	计算机处理数据的基本原理：硬盘数据<-->内存<-->CPU

CPU、内存、磁盘关系？
	CPU(Central Processing Unit)：中央处理器，作用是处理指令、执行操作、控制时间和处理数据。
	内存和磁盘都是存储器，受CPU指挥。
	计算机中所有的运算都由cpu完成，寄存器只是用于存储数据，不参与运算。
	CPU的工作流程：
		1、需要从寄存器中取出数据；
		2、进行运算，要不停地用存储器读写；
		3、计算出结果再返回到存储器里。
	说明：
		若磁盘够快时，电脑不需要内存。但磁盘太慢了，所以磁盘来担任1和3的工作，由内存来分担2的工作。
		内存的速度很快，在电脑运行过程中，CPU通常只和内存交换数据，但内存在断电后数据会全部丢失，因此电脑使用磁盘来作为主要存储器。
		I/O接口：是输入/输出的接口。磁盘就是通过I/O接口，把数据送到内存中供CPU处理的。


redis为什么采用单线程？
	1.官方答案：reids基于内存操作，CPU不是redis的瓶颈，redis的瓶颈最有可能是机器内存的大小或网络带宽。
	2.性能指标：关于redis的性能，官网上的介绍，普通笔记本轻松处理每秒几十万的请求。
	3.详细原因：
		-1）相比多线程代码更清晰，处理逻辑更简单；
		-2）不需考虑各种锁问题，不存在加锁释放锁操作，不存在死锁问题；
			redis有list、hash等复杂结构，这些结构可能进行很细粒度操作，因此可能需要考虑各种加锁控制和死锁问题。
		-3）CPU消耗。
			采用单线程，避免了不必要的上下文切换和竞争关系，也不存在多进程或多线程导致切换而消耗CPU。
	
	问：单进程单线程弊端
		无法发挥多核CPU性能。优化：可采用单线程多进程集群方案

	问：若让CPU成为redis瓶颈，或不想让服务器其它CPU闲置，那怎么设置？
		可考虑多起几个Redis进程，Redis是key-value数据库，不是关系型数据库，数据之间没有约束。只要客户端分清key放在哪个Redis进程即可。


IO多路复用技术：
	多路-指多个socket连接；复用-复用一个线程；
	多路复用主要有三种技术：select、poll、epoll。epoll是最新的也是目前最好的多路复用技术。
	多路复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈）。
	IO多路复用使用单线程来轮询描述符，将数据库的开、关、读、写都转换成事件，较少了线程切换时上下文的切换和竞争。


redis操作怎么保证原子性的？
	答：redis单线程

redis事务
	multi：标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。

redis持久化的几种方式，优缺点是什么，怎么实现的，区别是什么？
	两种：rdb、aof
	区别：rdb存数据，aof存写操作命令
	其他问题：
		aof和rdb的优缺点，你在项目中使用的哪一个

save和bgsave区别？
	save：由于redis单线程，save会造成阻塞，在rdb文件创建完成之前不处理任何请求。
	bgsave：会创建子进程，完成rdb文件的创建工作，父进程正常执行。
		在执行bgsave期间，主线程会拒绝save和bgsave命令；bgrewriteaof命令会延迟到bgsave命令结束之后执行。

redis的AOF如何缩减自身文件大小？
	描述：随着aof文件越来越大，里面会有大部分是重复命令或可以合并的命令(100次incr=set key 100)
	解决：执行bgrewriteaof命令对redis的AOF进行重写。
	重写的好处：减少aof日志尺寸，减少内存占用，加快数据库恢复时间
	从redis2.4开始，aof重写由redis自行触发，bgrewriteaof仅仅用于手动触发重写操作。
	旧的aof文件在bgrewriteaof成功之前不会被修改，因此bgrewriteaof操作失败不会造成任何数据丢失。



如何从10W个key中找到某个固定前缀开头的key？
	方式一：使用keys指令，匹配固定前缀
		redis是单线程的，keys指令会导致线程阻塞，线上服务会停顿，直到指令执行完毕后恢复
	方式二：使用scan指令
		scan指令可以无阻塞的提取指定模式的key列表，但会有一定的重复，需在客户端去重，其整体所花费的时间比key指令长。

redis的key设置？
	由于业务复杂，key一般设置比较复杂
	通常为“系统标识：模块名称：方法名称：参数”

redis的key如何寻址？
	类似于HashMap的寻址方式。

redis并发竞争key问题？Redis的并发竞争问题如何解决？分布式下redis如何保证线程安全？
	描述：多个子系统去set一个key
	方案一：分布式锁+时间戳
		单点锁：synchronized、Lock
		分布式锁：zookeeper、redis等
	方案二：利用消息队列


redis的主从复制实现（旧版）？
	分步骤：数据同步、命令同步
	--数据同步
	a.从节点连接主节点，发送sync命令（写缓存命令）；
	b.主节点接收到sync命令后，开始执行bgsave命令生成rdb文件，并使用缓冲区记录此后执行的所有写命令。
		附：bgsave命令用于后台异步保存当前数据库的数据到磁盘。redis fork出一个新子进程，原来redis进程（父进程）继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。
	c.主节点bgsave执行完后，向所有从节点发送rdb文件。
	d.从节点接收到rdb文件后丢弃所有旧数据，载入rdb文件的数据。
	--命令同步
	e.主节点rdb文件发送完后，开始向从服务器发送缓冲区的写命令。
	f.从节点完成rdb数据载入后，开始接收命令请求，并执行来自主节点缓冲区的写命令。
redis旧版主从复制可能出现问题？
	若从节点完成了rdb文件的数据同步后，主节点因网络原因中断复制，从节点重新连接后会再次发送sync命令，再次进行rdb数据同步。
redis新版主从复制实现？
	Redis从2.8版本开始，使用psync命令代替sync命令来执行复制时的同步操作。
	psync分为完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式。
	完整重同步：和sync的rdb数据同步一样
	部分重同步：用于处理断线后重复制情况，主节点只将断线期间的写命令发送给从服务器执行。



redis主从复制性能问题：
	1.master最好不要做任何持久化工作，如rdb和aof操作；
	2.若数据比较重要，某个slave开启aof备份数据，策略设值为每秒同步一次；
	3.master和slave最好在同一局域网内
	4.尽量避免在压力很大的主库上增加从库
	5.主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...

Redis集群模式（主从模式、哨兵模式、Cluster 集群模式）
redis集群模式实现？
	有三种实现：twemproxy、codis、redis自带
	redis cluster3.0自带集群：在redis集群内置很多哈希槽，redis会根据节点数量大致将哈希槽平均分配到不同节点上。当放置一个key-value时，redis会对key进行哈希求值，然后除所有哈希槽求得余数，根据余数得到应放置在哪个节点上。


redis实现分布式锁？
	在redis里创建一个key算加锁，完成相关操作后删除该key算释放锁。
	加锁：set my:lock:类名:方法名 EX 30 NX //30秒后自动释放，其它线程尝试加速时会失败
	解锁：del my:lock:类名:方法名
	附：set语法》 set key value [EX seconds] [PX milliseconds] [NX|XX]
		EX seconds:设置过期时间为seconds秒。执行 set key value EX seconds 等同于 setex key seconds value
		PX milliseconds：设置过期时间为milliseconds毫秒。执行 set key value PX milliseconds 等同于 psetex key milliseconds value
		NX:若key不存在时设置成功
		XX:若key存在时才设置成功
	其他问题：
		redis分布式锁的实现原理？setNX啥的
		redis分布式锁注意事项？30秒后值动释放
		zk实现分布式锁比较？


redis实现异步队列？
	list支持双端操作，一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息时，要适当sleep一会再重试。
	若不使用sleep，可以用blpop指令，在没有消息时它会阻塞直到消息到来。
	问：生产一次，消费多次？
		使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。
		缺点是消费者下线，消息会丢失，得使用专业的消息队列如RocketMQ等。


redis过期策略及内存淘汰机制？redis的缓存失效策略？
	问：redis内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？）
过期策略：
	redis采用定期删除+惰性删除策略。
	定期删除：指redis默认每隔10ms就随机抽取一些设置了过期时间的key，检查其是否过期，若过期就删除。不检查全部是为了避免redis卡死，部分未删除则根据惰性删除策略。
	惰性删除：在你获取某个key时，redis会检查其是否过期，若过期则此时删除，并不会返回任何东西。
	注：这样该删除的key可能还未删除，而导致redis内存越来越大，那么就该使用内存淘汰策略机制。
内存淘汰机制：
	# maxmemory-policy volatile-lru //在redis.conf配置
	--参数说明：
	noeviction 		内存不足时，写入报错
	allkeys-lru 	内存不足时，会移除最近最少使用的key。推荐使用。
	allkeys-random	内存不足时，随机移除某个key
	volatile-lru	内存不足时，在设置了过期时间的键空间中移除最近最少使用的key。这种情况一般是redis既当缓存，又做持久化存储时使用。
	volatile-random	内存不足时，在设置了过期时间的键空间中随机移除某个key。
	volatile-ttl	内存不足时，在设置了过期时间的键空间中优先移除有更早过期时间的key。


redis缓存相关问题：
	缓存和数据库双写一致性问题、缓存并发更新顺序问题、缓存穿透、缓存雪崩、缓存预热
	详情参考《redis学习.docx》
	缓存穿透问题？
		概念：访问不存在的数据，缓存不起作用，导致请求穿透到数据库，若存在大量这样的请求会导致数据库崩溃。
		解决：1、使用布隆过滤器，存储可能存在的key 2、将该key存下来，value为空对象，但设置较短的过期时间。这样第二次访问时缓存就有值了。
	缓存雪崩问题？
		若大量key同一时间失效，redis可能会出现短暂的卡顿现象，严重时可能会出现缓存雪崩。
		概念：缓存失效时间过于集中，导致大量请求到达数据库，导致数据库崩溃。
		解决：1、缓存失效时间增加1~5分钟随机值 2、数据库限流（加锁、或队列）



redis线程模型：
	文件事件处理器：redis基于Reactor模式开发了自己的网络事件处理器。其主要包括4部分：套接字(socket)、IO多路复用程序、文件事件分派器(dispatcher)、事件处理器
	工作原理：
		IO多路复用程序：负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。
		文件事件分派器：接收IO多路复用程序传过来的套接字，并根据套接字产生的事件类型调用相应的事件处理器。
	IO多路复用程序实现？


redis跳跃表问题？
	详情：https://blog.csdn.net/idwtwt/article/details/80233859
	跳跃表在redis中主要是有序表的一种底层表现。对于普通链表的查找不能使用二分法，需要从头一个个找。而对于跳跃表提供了类似二分法查找，先跳转到最大值，若小于则跳到中间。


redis的hash算法用的是啥？
	redis应该是使用一致性hash算法---MurmurHash3 算法，具有低碰撞率优点，google改进的版本cityhash也是redis中用到的哈希算法。
	现有的主流的大数据系统都是用的 MurmurHash本身或者改进
	Nosql是非关系型数据库，因为不需要满足关系数据库数据一致性等复杂特性所以速度快；


为什么要用redis而不用map/guava做缓存?
	redis可以用几十个G内存来做缓存，Map不行，一般jvm也就分几个G内存，太大影响gc时间。



问：怎么快速删除10w个key？
	使用管道(redis pipeline)

redis底层协议resp
	redis客户端与redis-server交互通信，采用tcp请求/响应模型；
	我们通过redis客户端执行命令(如set key value)，客户端遵循resp协议，将命令的协议串发送给redis-server执行，redis-server执行完后再同步返回结果。

为什么会出现redis管道(pipeline)?
	redis客户端与redis服务端通信采用cs模式，每次交互都是完整的请求/响应模式。
	我们使用jedis或lettuce执行redis命令，每次都是建立socket连接，并等待返回。

	每个命令底层建立tcp连接的时间是省不掉的，当需要对一组kv进行批量操作时，这组命令的耗时=sum(建立连接时间+发送命令、返回结果)，随着批量操作的key越多，时间累加呈线性增长。这样便出现了像redis连接池的技术，如JedisPool。

	当需要对一组kv进行批量操作时，JedisPool池子里的connection连接、极端情况都被用完了，怎么办？
	--需要等待JedisPool池里有可复用的connection才能继续执行。若在指定的等待时间内没有等到idle空闲连接，就报异常了

	如果能将多条命令“合并”到一起，进行一次网络IO，性能会提高不少吧。这就是今天的主角——Redis pipeline。

redis管道原理？
	当client 使用pipeline 发送命令时，redis-server必须将部分请求放到队列中（使用内存），执行完毕后一次性发送结果。
	客户端将多个命令缓存起来，缓冲区满了就发送（将多条命令打包发送）；有点像“请求合并”。服务端接受一组命令集合，切分后逐个执行返回。

pipeline与Redis事务(multi)
	multi：标记一个事务块的开始。 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。
	pipeline：客户端将执行的命令写入到缓冲中，最后由exec命令一次性发送给redis执行返回。

	multi 是redis服务端一次性返回所有命令执行返回结果。
	pipeline管道操作是需要客户端与服务端的支持，客户端将命令写入缓冲，最后再通过exec命令发送给服务端，服务端通过命令拆分，逐个执行返回结果。

	--两者的区别：
	pipeline选择客户端缓冲，multi选择服务端队列缓冲；
	请求次数的不一致，multi需要每个命令都发送一次给服务端，pipeline最后一次性发送给服务端，请求次数相对于multi减少
	multi/exec可以保证原子性，而pipeline不保证原子性
























redis模拟session，除了redis你还考虑过别的吗？
Redis用过哪些数据数据，以及Redis底层怎么实现？
redis的数据结构 最常问hash是什么，sorted set怎么实现的？
redis是怎么保证高可用的，主从复制实现？主从和集群怎么加在一起？redis集群怎么进行数据分配（hash槽）？
redis集群如何搭建
redis如何主从同步
Redis缓存穿透，缓存雪崩
Redis集群，高可用，原理
redis有没有用过，常用的数据结构以及在业务中使用的场景，redis的hash怎么实现的，rehash过程讲一下和JavaHashMap的rehash有什么区别？redis cluster有没有了解过，怎么做到高可用的？redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？









