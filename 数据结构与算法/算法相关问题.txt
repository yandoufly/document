

算法题：
	走迷宫
	游戏通关
	走台阶
	断钢筋
	背包问题
排序算法：
	八大排序算法及复杂度介绍？快排、堆排序、归并排序
	哪些排序算法是稳定的，哪些是不稳定的？
	快速排序，过程，复杂度？什么情况下适用，什么情况下不适用？
	归并排序的过程？时间复杂度？空间复杂度？ 
	二分搜索的过程
	
链表：
	反转链表
	判断链表是否有环
	交叉链表的交点
	复杂链表的复制
	二叉树变成双向链表
	什么是二叉平衡树，如何插入节点，删除节点

树：
	如何遍历一棵二叉树？
	参考：TreeTest.java
	前序遍历、中序遍历、后序遍历
	前序(MLR-根左右)
	中序(LMR-左根右)
	后序(LRM-左右根)



做搜索、回溯问题的套路是画图，代码其实就是根据画出的树形图写出来的。
如何画图？
	1、根据题目中的用例，画一个图，因为是搜索，因此呈现的是一个树形结构图，并且在这个树形结构中会体现出递归结构。
	2、根据题目中的用例，比对自己画图的结果和题目的结果的差异，如果一样，说明我们的分析没有错；如果不一样，说明我们的分析有误，一定有哪一个环节漏掉了或者分析错误，根据找到的问题调整算法。


递归算法步骤：
	1、了解递归函数功能
	2、找出递归结束条件
	3、找出函数的等价关系式


算法问题：
	给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少？
	给你一个数组，如何里面找到和为K的两个数？
	100000个数找出最小或最大的10个？topK问题
	一堆数字里面继续去重，要怎么处理？
	八大排序算法？时间复杂度？
	实现一致性hash？


问：最优的集合去重，时间复杂度为O(1)。
	常规做法：本来10W条记录的记录，若新添加一条记录，则都要跟原来10W条记录做对比，起时间复杂度为O(n)。
	优化：类似于HashMap的结构，先创建一个大的数组，直接将集合元素插入数组中，若该数组下标已存在元素，则说明是重复元素

问：求数组的最长连续递增数列，如：4，200，3，1，100，2。结果是1，2，3，4
	算法1：先排序，然后从前往后遍历，if (array[i]-array[i-1]==1) dp[i]=dp[i-1]-1; else dp[i]=1;
	面试官：用一个hashtable，hash到4的时候，看看hash（3）和hash（5）是否存在，类似这样的思路


写出LRU和LFU的淘汰算法？
LRU(全称Least Recently Used，最近最久未使用)实现：
	方案：利用一链表。当链表未满时，未命中数据插到链表头部，命中数据移到头部；当链表满后将链表尾部的数据丢弃。
	缺点：要遍历才知道某元素是否存在或命中
	优化：链表+Map。Map用来判断某元素是否存在


问：反转链表
	--就地反转：1指向3，2指向1。反复循环直到1.next为null；
	dummy->1->2->3->4->5
	dummy->2->1->3->4->5
	dummy->3->2->1->4->5
	dummy->4>-3->2->1->5
	dummy->5->4->3->2->1


问：数组中查找两数之和为K的序列对
	算法：借助hashMap存储计算过程，对于第i元素，若存在key=nums[i]则直接返回key和value，若不存在则存入HashMap中<sum-nums[i], nums[i]>


问：对于5位的01串，每一位都可能是0或1，一共32种可能。它们前几个是00000、00001、00010...，请按从小到大打印这32种01串。
	规律：每一位都可能是0或1，使用可以使用for循环输出0和1；有5位则使用5个for循环输出
	--代码如下：
	for(int a = 0; a < 2; a++)
			for(int b = 0; b < 2; b++)
				for(int c = 0; c < 2; c++)
					for(int d = 0; d < 2; d++)
						for(int e = 0; e < 2; e++)
							System.out.printf("%d%d%d%d%d\n", a,b,c,d,e);

问：从数组中取出n个元素的所有组合
	规律：若从数组中取出1位，遍历一遍数组即可；若取出2位，遍历2遍数组即可，但第二位数的下标一定小于第一位数下标。

	--代码如下：从数组中任意取出3位数
	int[] num = {1, 2, 3, 4, 5, 6};
	for (int a = 0; a < num.length; a++) {
		for (int b = 0; b < num.length; b++) {
			if (b <= a) continue;
			for (int c = 0; c < num.length; c++) {
				if (c <= b) continue;
				System.out.printf("%d,%d,%d\n", num[a], num[b], num[c]);
			}
		}
	}

问：topK问题
	描述：从arr[1, n]这n个数中，找出最大的k个数。
	方法一：快排，时间复杂度O(n*lg(n))
	方法二：局部排序，循环k次，找出最大的k个数，时间复杂度O(n*k)
	方法三：堆实现。堆先存入k个值并已排序；然后存入第K+1的值，若大于堆内扫描到的元素，则替换并调整堆，以保证堆内的k个元素总是当前最大的k个元素。
	方法三：数组实现。数组中先存入K个值。当存入第k+1的值时，先扫描数组得到最小值与第k+1值比较，若大于的替换，以保证数组内k个元素总是当前最大的k个元素。


问：如何从大量url中找出相同的url？
	原文：https://mp.weixin.qq.com/s/6Q6hOoF3eshWnWFwR9SjTg
	描述：给定a、b文件，各存放50亿个url，每个url各占64B，内存限制是4G。请找出a、b两个文件共同的url。
	解答思路：
		每个url占64B，那么50亿个URL占用的空间大小约为320GB。
		5,000,000,000 * 64B ≈ 5GB * 64 = 320GB
		因为内存大小只有4G，因此不可能一次性把所有url加载到内存中处理。
		对于这种类型题目，一般采用分支策略，即：把一个文件中的url按照特征划分为多个文件，使得每个小文件大小不超过4G，这样可以把这个小文件读到内存中进行处理。
	思路如下：
		首先遍历文件 a，对遍历到的 URL 求 hash(URL) % 1000 ，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。
		接着遍历 ai( i∈[0,999] )，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。
	方法总结：
		1、分而治之，进行哈希取余；
		2、对每个子文件进行 HashSet 统计。