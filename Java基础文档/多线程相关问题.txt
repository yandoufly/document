

问：多线程开发良好的实践？
	给线程命名
	最小化同步范围
	优先使用volatile
	尽可能使用更高层次的开发工具而非wait()和notify()来实现线程通信，如BlockingQueue，Semeaphone等
	优先使用并发容器而非同步容器
	考虑使用线程池


多线程好处？
	提高资源利用率，CPU不会因为某个线程需要等待资源而进入空闲状态。
	例如，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。CPU等待第一个文件被读取完。然后开始读取第二个文件；当第二文件在被读取的时候，CPU会去处理第一个文件。


线程间通信方式：
	1、休眠唤醒方式:
		Object的wait、notify、notifyAll #必须再同步代码块中使用，没被锁怎么会存在等待/唤醒
		Condition的await、signal、signalAll
	2、CountDownLatch:用于某个线程等待若干个其它线程执行完之后，它才执行。
	3、CyclicBarrier:一组线程等待至某个状态之后再全部同时执行
	4、Semaphore:用于控制对某组资源的访问权限
		实例：8个工人使用3台机器，机器为互斥资源（即每次只能一个人使用）
	5、阻塞队列BlockingQueue就是为线程之间共享数据而设计的。
	注：
		我们唤醒时应使用notifyAll()，如果使用notify()随机唤醒的可能是同一类线程，这样会导致死锁；
		将if改成while，比如生产者线程有多个，当本生产者线程wait之后，假如另一个生产者线程得到锁（本该消费者得到），如果是if，那么此线程就会继续执行，会导致数据错乱。如果是while则会继续等待。



如何让主线程等待子线程执行完后再执行？
	描述：现主线程X，和两个子线程A和B，主线程X需要在线程A和B执行完成之后再执行。
	方法1：使用join方法。在主线程X中添加 threadA.join(); threadB.join();
	方法2：使用CountDownLatch实现。
	方法3：使用Callable和FutureTask类，通过等待子线程返回值


Synchronized关键字
	--是一种同步锁。
	1、修饰代码块，称为同步代码块，其作用范围是大括号{}里面的代码，作用的对象是调用该代码块的对象。
	2、修饰方法，称为同步方法，其作用范围是整个方法，作用的对象是调用该方法的对象。
	3、修饰静态方法，其作用范围是整个静态方法，作用的对象是这个类的所有对象。
	4、修饰类，其作用范围是synchronized后面大括号{}里面的代码，作用的对象是这个类的所有对象。


Synchronized和Lock区别
	1）Synchronized是Java内置关键字，可重入锁、不可中断、非公平；而Lock是Java类，可重入锁、可中断、可公平。
	2）Synchronized无法判断是否获取锁的状态；Lock可以判断是否获取到锁。
	3）Synchronized会自动释放锁（执行完/抛异常都会释放锁）；Lock需在finally中执行unlock方法释放锁，否则容易造成线程死锁。
	4）Synchronized锁适合少量同步代码的同步问题，Lock锁适合大量同步代码的同步问题。


如何避免死锁？
	1、加锁顺序(线程需按某种顺序加锁)
	2、加锁时限(线程尝试获取锁时加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁)
	3、死锁检测

CAS概念、ABA问题、Unsafe底层实现
解决ABA问题：使用AtomicStampedReference类
	AtomicStampedReference(初始值, 时间戳) --构造函数设置初始值和初始时间戳
	getReference()	--获取预期值
	getStamp()	--获取时间戳
	compareAndSet(预期值, 更新值, 预期时间戳, 更新时间戳) --实现CAS时间戳和预期值对比

ThreadLocal用途

多线程有什么用？
	1、发挥多核CPU优势。
		单核CPU上所谓的"多线程"那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程"同时"运行罢了。
		多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。
	2、防止阻塞

什么是线程安全？
	如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

什么是多线程的上下文切换？
	指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。


Java中用到的线程调度算法是什么？
	抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。
	
Thread.sleep(0)的作用是什么？
	由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

线程调度器(Thread Scheduler)和时间分片(Time Slicing)
	线程调度器：是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个并启动它，它的执行便依赖于线程调度器的实现。
	时间分片：指的是将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间基于线程优先级或线程等待的时间。
	注：线程调度由应用程序来控制更好，即不要让你的程序依赖于线程的优先级。


什么是自旋？
	synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。	



什么是Java内存模型？
	Java内存模型将内存分为了主内存和工作内存。


volatile关键字作用？volatile的实现原理？
	主要作用：可见性、禁止指令重排序(详情查看volatile重排序规则)。
	实践：volatile和cas结合，能保证原子性。

Synchronized实现原理以及锁优化？
synchronized底层原理：
	进入时，执行monitorenter，将计数器+1，释放锁monitorexit时，将计数器-1。当一个线程判断到计数器为0时，则当前锁空闲，可以占用；反之当前线程进入等待状态。

ThreadLocal关键字作用？
	创建线程的本地变量。目的是为了线程隔离，让每个线程都能拥有属于自己的变量空间，线程之间互不影响。
	内部维护了ThreadLocal.ThreadLocalMap，把数据进行隔离


CyclicBarrier和CountDownLatch的区别？
	CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行。
	CountDownLatch的某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行。
	CyclicBarrier可以重复使用，CountDownLatch变成0后不能重复使用。
问：怎么实现所有线程在等待某个事件的发生才会去执行？CyclicBarrier


Semaphore作用？Java的信号灯？
	Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。
	Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只可有n个线程可以访问，若超过n个则等待，直到某线程执行完毕这段代码块后再进入。


乐观锁：CAS MVCC
什么是CAS？
	CAS，全程compare and swap，即比较并替换。
	假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。
	当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。

乐观锁和悲观锁的使用场景？




什么是AQS？
	AQS为AbstractQueuedSychronizer类，翻译为抽象队列同步器。
	如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。
	AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。
	AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。

	实现思路：线程首先会尝试获取锁，若失败则将该线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。


AQS实现公平锁和非公平锁：
基于AQS的锁（如ReentrantLock）原理：
	1）有一变量state，初始值为0，若当前线程A获取一次锁则state++，释放一次则state--，锁会记录当前持有的线程。
	2）当线程A拥有锁时(state>0)。线程B尝试获取锁时对该state进行CAS(0, 1)操作，尝试几次失败后就挂起，进入一个等待队列。
	3）若线程A恰好释放(--state == 0)，线程A会唤醒等待队列中第一个线程，即在等待队列的线程B，线程B被唤醒后再去对该state进行CAS(0, 1)操作
非公平锁实现：
	线程A唤醒线程B时，若此时有线程C也在尝试对state进行CAS(0, 1)操作，会与等待队列中的线程B进行抢夺，谁抢到就算谁的。
公平锁实现：
	线程A唤醒线程B时，若此时线程C发现有线程B在等待队列，直接将自己进入等待并挂起，线程B优先获取锁。




为什么要用线程池？怎么设计？
	避免频繁地创建和销毁线程，达到线程对象的重用。
	核心线程数(corePoolSize)、最大线程数(maximumPoolSize)、线程存活时间(keepAliveTime)、阻塞队列(workQueue)、拒绝策略(handler)

Linux环境查找哪个线程使用CPU最高。
	1）获取项目的pid
		jps或ps -ef | grep java
	2）查看项目中每条线程占用CPU百分比
		top -h -p pid
		使用"top -H -p pid"+"jps pid"可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因


1.并发高、任务执行时间短的业务怎样使用线程池？
	线程池中线程数目可以设值为CPU核数+1，减少线程上下文切换。
2.并发不高、任务执行时间长的业务怎样使用线程池？
	-1）业务时间长集中在IO操作上，也就是IO密集型任务，因为IO操作并不占用CPU，所以不要让所有CPU闲下来，可以加大线程池中线程数目，让CPU处理更多业务。
	-2）业务时间长集中在计算操作上，也就是计算密集型任务，设值为CPU核数+1，减少线程上下文切换。
3.并发高、任务执行时间长的业务怎样使用线程池？
	这类任务的关键不在于线程池，而在于整体架构的设计。
	考虑将业务里的数据做缓存、或增加服务器、或者将业务拆分成一个一个小任务。


CPU核数：
	// 最大可用的CPU核数
	public static final int PROCESSORS = Runtime.getRuntime().availableProcessors();
	Java8 parallelStream共享线程池，默认其线程数是最大可用的CPU核数-1个。
	线程池设置：密集型应用是cpu核数+1，非计算密集型是2*cpu核数



synchronize的底层实现？与reentryLock的区别？


计数器？AtomicInteger就可以了
生产者和消费者模式？

线程池：
	线程池：所有实现Executor接口的类。可使用Executors工具类来操作线程池。
	作用：
	4种线程池区别：newFixedThreadPool、newCachedThreadPool、newSingleThreadExecutor、newScheduledThreadPool
	ThreadPoolExecutor构造函数及对应参数说明
		参数说明：corePoolSize、maximumPoolSize、keepAliveTime、workQueue、threadFactory、handler
4种线程池：
newFixedThreadPool	固定线程池
	核心线程数为CPU核数*N，最大线程数为整型最大值。
	采用无界队列LinkedBlockingQueue，任何时间内最多有nThreads个线程处于活动状态执行任务。
newCacheThreadPool	缓存线程池
	核心线程数为0，最大线程数为整型最大值，这意味着所有任务一提交就加入到阻塞队列中。
	阻塞队列为SynchronousQueue，阻塞队列没有存储空间，只要有请求就必须找到一条空闲线程去处理这个请求，找不到则在线程池新开辟一条线程
	当线程池中的线程60s没有执行任务就终止，所以长时间处于空闲状态时，这种线程池几乎不占用资源。
	适合处理执行时间短的任务。
	缺点：若主线程提交任务的速度远大于CacheThreadPool的处理速度，则CacheThreadPool会不断地创建新线程来执行任务，这样可能会导致系统耗尽CPU和内存资源。
singleThreadPoolExecutor	单线程的线程数
	corePool和maximunPoolSize都为1，采用无界队列LinkedBlockingQueue。
	使用单一worker线程，它只会用唯一的工作线程来执行任务，保证所有任务按指定顺序(FIFO,LIFO,优先级)执行。
	实例：一些不太重要的收尾，日志等工作可以放到单线程的线程中去执行。日志记一般情况会比较慢，顺序执行会拖慢整个接口，堆积更多请求，还可能会对数据库造成影响（事务开启中），所以日志记录完全可以扔到单线程的线程池中，一条条的处理。
NewScheduledTreadPool	固定个数的线程池
	？？


读写锁的实现方式？16位int的前八位和后八位分别作为读锁和写锁的标志位

Synchronized在静态方法和普通方法的区别？



volatile和atomic的区别
atomic底层是如何实现的


