jvm调优：
	目标：避免fullGC和gc频率，还有每次gc时间。达到最终gc时间小，程序停顿小。
	堆大小的调优：
		一般来说调整参数越大越好，1、降低gc频率但也增加单词gc时间；2、对象更有可能成为垃圾。
		平衡调整new和old的比例。可以xms/xmx调整为一样大，初始化一般为内存的1/64，1/4。避免频繁调整，每次调整都会触发一次FullGC.当然也不总是，1、堆调整代价大但是如果死机了呢。还不如一次fullgc
	新生代调优：
		1、Eden区大小调整，xmn，降低gc频率
		2、晋升,(1)尽可能让对象待在survival中，使之在新生代被收回，不然进入old区，降低旧生代的对象和gc。(2)调整比例，平衡点。New 里面的Eden和survival0. survival01  8:1:1。(3)新生代长时间没被回收的，设置阀值，进行放入Old，避免频繁copy
	旧生代的调优：
		尽可能对新生代调优，在不紧要的时候受用fullgc。加Cpu，硬件调整。
		程序优化

jvm内存分配规则：
	详情：https://blog.csdn.net/hyg0811/article/details/101444643
1.对象优先在eden分配：
2.大对象直接进入老年代：
	大对象指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。
	虚拟机提供一个-XX:PretenureSizeThreshold参数，大于该值的对象直接在老年代分配。其目的是避免在Eden区及两个Survivor区之间发生大量的内存复制
3.长期存活的对象将进入老年代
	虚拟机给每个对象定义了一个对象年龄（Age）计数器。每经过一次Minor GC则对象年龄+1，当年龄达到15岁（默认值），就会晋升到老年代。
	年龄阈值设置：-XX:MaxTenuringThreshold

	问：jvm的分代年龄为什么是15？
		在32位HotSpot虚拟机中，若对象处于未被锁定的状态下，那么Mark Word的32bit空间中25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0。
		因此，对象的分代年龄占4位，也就是0000，最大值为1111也就是最大为15，而不可能为16，20之类的了。
4.动态对象年龄
	虚拟机并不是永远地要求兑现过的年龄必须达到了MaxTenuringThreshold才能晋升老年代。
	对象能晋升老年代条件：
		-1）虚拟机并不是永远地要求兑现过的年龄必须达到了MaxTenuringThreshold才能晋升老年代；
		-2）若Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

方法区卸载Class的条件：
	1）该类所有的实例已经被回收
	2）加载该类的ClassLoader已经被回收
	3）该类对应的java.lang.Class对象没有任何地方被引用
	附：方法区除了回收无用class，也回收废弃常量，即没有被引用常量

类加载：
三个类加载器：
	启动类加载器(BootStrap classloader):负责将Java_HOME/lib下的类库加载到虚拟机内存中，比如rt.jar
	扩展类加载器(Extension classloader):负责将JAVA_HOME/lib/ext下的类库加载到虚拟机内存中
	应用程序类加载器(Application classloader):负责加载classpath环境变量下指定的类库。如果程序中没有自定义过类加载器，那么这个就是程序中默认的类加载器。
双亲委派模型
	概念：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
Java为什么要设计双亲委派模型？
	防止自定义的一些跟jdk标准库中冲突的全限定名的类被加载，导致标准库函数不可用。
为什么要自定义类加载器？
	我们需要的类不一定都在classPathl路径下，对于自定义路径中的class类文件的加载，我们需要实现自定义类加载器。


gc什么时候触发？
	1、System.gc()人工调用回收；2、系统自身决定gc
gc怎么判断对象可以回收？
	引用计数法、可达性分析
MinorGC、FullGC触发条件？
	MinorGC触发条件：当Eden区满时触发。
	FullGC触发条件：
		老年代空间不足
		方法去空间不足
		通过MinorGC后进入老年代的平均大小大于老年人的可用内存
		由Eden区、FromSpace区向ToSpace区复制时，对象大小大于ToSpace可用内存，则把该对象转存到老年代，但老年代的可用内存小于该对象的大小。
gc算法有哪些？
	标记清除算法、标记整理算法、复制回收算法、分代收集

回收期的选择(gc算法的实现)？
	Serial minorGC， serialOld majorGC串行回收，单线程
	parnew  minorGC 单，多线程
	parallel scavenger(并行回收)minorGC   parallelOld  majorGC
	Cms  majorGC并发标记清除收集器，初始标记--并发标记--重新标记--并发清除
	G1收集器 minorGC 、majorGC. Garbage First Collector，初始标记--并发标记--最终标记--筛选回收

gc监控工具：jvm参数命令行日志输出，MAT,JVisualVM


jvm相关：
	JVM内存模型，GC机制和原理；GC分哪两种；什么时候会触发Full GC？

	JVM里的有几种classloader，为什么会有多种？

	什么是双亲委派机制？介绍一些运作过程，双亲委派模型的好处；(这个我真的不会...)

	什么情况下我们需要破坏双亲委派模型；

	常见的JVM调优方法有哪些？可以具体到调整哪个参数，调成什么值？

	JVM虚拟机内存划分、类加载器、垃圾收集算法、垃圾收集器、class文件结构是如何解析的


内存溢出和内存泄漏的区别？
	内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现OOM；
	内存泄漏是指分配出去的内存不再使用，但是无法回收。


类加载：
	在Java代码中，类型的加载、连接、初始化过程都是在程序运行期完成的。
	类型指的是？ 
		类型指的是我们Java源代码通过编译后的class文件
	通过什么加载？
		类加载
	加载到哪里？
		加载到方法区/元空间的数据区中
双亲委派机制：



内存模型以及分区，需要详细到每个区放什么。
堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。
对象创建方法，对象的内存分配，对象的访问定位。
GC 的两种判定方法
GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
GC 收集器有哪些？CMS 收集器与 G1 收集器的特点
Minor GC 与 Full GC 分别在什么时候发生？
JVM 内存分哪几个区，每个区的作用是什么?
如和判断一个对象是否存活?(或者 GC 对象的判定方法)
java 中垃圾收集的方法有哪些?
类加载器双亲委派模型机制？
java 内存模型，java 类加载过程?
什么是类加载器，类加载器有哪些?
简述 java 内存分配与回收策率以及 Minor GC 和Major GC
说说GC的过程
强制young gc会有什么问题？
知道G1么？ 回收过程是怎么样的？ 你提到的Remember Set底层是怎么实现的？
CMS GC有什么问题？
怎么避免产生浮动垃圾？
1.7和1.8的JVM有哪些不同？
1.8的垃圾回收算法，介绍你所知道的垃圾回收算法，CMS垃圾回收器简单介绍

JVM内存模型
GC垃圾回收算法
讲解新生代 老年代
说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分
垃圾回收算法以及垃圾回收器
CMS的回收步骤
G1和CMS的区别
CMS哪个阶段是并发的哪个阶段是串行的？
G1内部是如何分区的（region）


